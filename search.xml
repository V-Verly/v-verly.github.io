<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Codeforces Round 628 (Div. 2)</title>
      <link href="/2020/03/17/Codeforces%20Round%20628%20(Div.%202)/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://codeforces.com/contest/1325" target="_blank" rel="noopener">Codeforces Round #628 (Div. 2)</a><br>久违的(?)更新<br>实习offer疑似要因为实习时间太短告吹了，只能打打cf维持生活这样子</p></blockquote><a id="more"></a><hr><h2 id="A-EhAb-AnD-gCd"><a href="#A-EhAb-AnD-gCd" class="headerlink" title="A. EhAb AnD gCd"></a>A. EhAb AnD gCd</h2><p>给一个数x，找到满足$GCD(a,b)+LCM(a,b)=x$的数对a,b</p><p>很显然是1+(x-1)嘛</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"><span class="keyword">while</span>(t --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, <span class="number">1</span>, x - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="B-CopyCopyCopyCopyCopy"><a href="#B-CopyCopyCopyCopyCopy" class="headerlink" title="B. CopyCopyCopyCopyCopy"></a>B. CopyCopyCopyCopyCopy</h2><p>把长度为n的序列复制n次，问它的最长上升子序列长度。</p><p>第i组有效的是第i个大的数，所以答案是序列里不同数字的个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"><span class="keyword">while</span>(t --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) st.insert(a[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,(<span class="keyword">int</span>)st.size());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="C-Ehab-and-Path-etic-MEXs"><a href="#C-Ehab-and-Path-etic-MEXs" class="headerlink" title="C. Ehab and Path-etic MEXs"></a>C. Ehab and Path-etic MEXs</h2><p>给树上每条边一个0~n-2的不重复权值，怎么使树上所有路径的MEX最大值最小。</p><p>我的思路是把最小值赋给叶子的父边，这样在叶子个数超过3（也就是不是链的情况）时，MEX的最大值不会超过2。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> de[maxn], pos[maxn];</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; edge[maxn];</span><br><span class="line"><span class="keyword">int</span> res[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">edge[i] = make_pair(u, v);</span><br><span class="line">de[u] ++, de[v] ++;</span><br><span class="line">pos[u] = i, pos[v] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mex = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(res, <span class="number">0xff</span>, <span class="keyword">sizeof</span> res);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(de[i] == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(res[pos[i]] == <span class="number">-1</span>) res[pos[i]] = mex ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(res[i] == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mex ++);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="D-Ehab-the-Xorcist"><a href="#D-Ehab-the-Xorcist" class="headerlink" title="D. Ehab the Xorcist"></a>D. Ehab the Xorcist</h2><p>给定两个非负整数$u$,$v$，求一个元素个数最少的数组，满足它们的异或和为$u$,和为$v$.</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>先特判u=0或者u=v的情况。当v&gt;u或者<code>(v-u)%2==1</code>时无解。</p><p>对于<code>(v-u)%2==0</code>的情况，如果<code>u&amp;((v-u)&gt;&gt;1)==0</code>，答案就是<code>u^((v-u)&gt;&gt;1),(v-u)&gt;&gt;1)</code>，否则就是<code>u,(v-u)&gt;&gt;1,(v-u)&gt;&gt;1</code>，因为前者将a[0]和a[1]合并之后不影响它们的和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll u, v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;u, &amp;v);</span><br><span class="line"><span class="keyword">if</span>(u &gt; v) <span class="keyword">return</span> <span class="number">0</span> * <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line"><span class="keyword">if</span>(u == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(v == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span> * <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(v % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n%lld %lld\n"</span>, <span class="number">2</span>, v / <span class="number">2</span>, v / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span> * <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(u == v) <span class="keyword">return</span> <span class="number">0</span> * <span class="built_in">printf</span>(<span class="string">"%d\n%lld\n"</span>, <span class="number">1</span>, u);</span><br><span class="line"><span class="keyword">if</span>((v - u) % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ll tmp = v - u;</span><br><span class="line">tmp /= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>((u &amp; tmp) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">2</span>);</span><br><span class="line">ll res1 = u, res2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i ++) <span class="keyword">if</span>((tmp &gt;&gt; i) &amp; <span class="number">1</span>) </span><br><span class="line">&#123;</span><br><span class="line">(res1 ^= (<span class="number">1l</span>l &lt;&lt; i));</span><br><span class="line">(res2 ^= (<span class="number">1l</span>l &lt;&lt; i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>, res1, res2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"3\n%lld %lld %lld\n"</span>, u, tmp, tmp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="E-Ehab’s-REAL-Number-Theory-Problem"><a href="#E-Ehab’s-REAL-Number-Theory-Problem" class="headerlink" title="E. Ehab’s REAL Number Theory Problem"></a>E. Ehab’s REAL Number Theory Problem</h2><p>给定一个长度为$n(1 \le n \le 10^5)$的数组，元素大小满足$(1 \le a_i \le 10^6)$且元素的因数个数不超过7.找出最小的子集大小，满足子集中元素的积是一个完全平方数。</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>首先对元素做预处理，只留下满足<code>cnt%2==1</code>的质数（因为平方数不影响答案）。</p><p>特判预处理后存在元素为1或者两个元素相等的情况。</p><p>考虑元素的因数个数不超过7这个条件，说明元素本身只有最多2个质因数（如果质因数为3，因数个数等于8）。</p><p>对于元素的质因数p,q（如果小于2，令其它为1）建图，连边p-q，边表示某个元素。对于图上的路径s-t，除了起点s和终点t，其它质数都出现了两次。所以答案就是这张图上的最小环，枚举起点，用BFS树求解即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> a[maxn], dis[maxm];</span><br><span class="line"><span class="keyword">bool</span> vis[maxm];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[maxm];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j * j &lt;= a[i]; j ++) <span class="keyword">while</span>(a[i] % (j * j) == <span class="number">0</span>) a[i] /= j * j;</span><br><span class="line">&#125;</span><br><span class="line">sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line"><span class="keyword">if</span>(a[<span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span> * <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++)</span><br><span class="line"><span class="keyword">if</span>(a[i] == a[i + <span class="number">1</span>]) <span class="keyword">return</span> <span class="number">0</span> * <span class="built_in">puts</span>(<span class="string">"2"</span>);</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; val;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j * j &lt;= a[i]; j ++) <span class="keyword">if</span>(a[i] % j == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">tmp.push_back(j);</span><br><span class="line"><span class="keyword">while</span>(a[i] % j == <span class="number">0</span>) a[i] /= j; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[i] &gt; <span class="number">1</span>) tmp.push_back(a[i]); </span><br><span class="line"><span class="keyword">while</span>(tmp.size() &lt; <span class="number">2</span>) tmp.push_back(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> u = tmp[<span class="number">0</span>], v = tmp[<span class="number">1</span>];</span><br><span class="line">edge[u].push_back(v);</span><br><span class="line">edge[v].push_back(u);</span><br><span class="line">val.insert(u);</span><br><span class="line">val.insert(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = inf;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!edge[i].size()) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> v : val) vis[v] = <span class="literal">false</span>, dis[v] = inf;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">que.push(i); </span><br><span class="line">vis[i] = <span class="literal">true</span>, dis[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!que.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front(); </span><br><span class="line">que.pop();</span><br><span class="line">vis[u] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> v : edge[u])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[v] &gt; dis[u] + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">dis[v] = dis[u] + <span class="number">1</span>;</span><br><span class="line">vis[v] = <span class="literal">true</span>;</span><br><span class="line">que.push(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(vis[v])</span><br><span class="line">res = min(res, dis[u] + dis[v] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res == inf ? <span class="number">-1</span> : res);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="F-Ehab’s-Last-Theorem"><a href="#F-Ehab’s-Last-Theorem" class="headerlink" title="F. Ehab’s Last Theorem"></a>F. Ehab’s Last Theorem</h2><p>给定一张n个点的图，保证至少存在以下一种情况:</p><ul><li><p>存在一个恰好有$\lceil\sqrt{n}\rceil$个点的独立集</p></li><li><p>存在一个至少有$\lceil\sqrt{n}\rceil$个点的环</p></li></ul><p>找到上述其中一种的任意一个合法解并输出。</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>对于情况2，只需要dfs树找到图的最大环。如果不满足条件，对dfs树上的节点01染色，保证取一个点就不取连向它的所有点来求独立集。</p><p>赛中没调出来还越写越丑，码力属实不大行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[maxn];</span><br><span class="line"><span class="keyword">int</span> dep[maxn], pre[maxn], lim;</span><br><span class="line"><span class="keyword">bool</span> mark[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dep[u] = dep[pre[u]] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> v:edge[u])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(v == pre[u]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(!dep[v]) pre[v] = u, dfs(v);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[u] - dep[v] + <span class="number">1</span> &gt;= lim)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"2\n%d\n%d "</span>, dep[u] - dep[v] + <span class="number">1</span>, u);</span><br><span class="line"><span class="keyword">int</span> now = u;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">now = pre[now];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, now);</span><br><span class="line">&#125;<span class="keyword">while</span>(now != v);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!mark[u]) <span class="keyword">for</span>(<span class="keyword">auto</span> v : edge[u]) mark[v] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">lim = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">while</span>(lim * lim &lt; n) lim ++;</span><br><span class="line"><span class="keyword">while</span>(m --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">edge[u].push_back(v);</span><br><span class="line">edge[v].push_back(u);</span><br><span class="line">&#125;</span><br><span class="line">pre[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; lim; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!mark[i]) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line">lim --;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Codeforces Round </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「CodeForces-1253F」Cheap Robot(最小瓶颈路)</title>
      <link href="/2019/11/22/Codeforces-1253F/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://codeforces.com/contest/1253/problem/F" target="_blank" rel="noopener">F - Cheap Robot</a><br>给定一个无向图，其中1-k为充电桩。经过长度为w的边会消耗w的电量，可在任意充电桩充满电。q次询问，每次询问从一个充电桩到另一个充电桩所需要的最小电池容量。</p></blockquote><a id="more"></a><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个无向图，其中1-k为充电桩。经过长度为w的边会消耗w的电量，可在任意充电桩充满电。q次询问，每次询问从一个充电桩到另一个充电桩所需要的最小电池容量。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>对于任意一个非充电桩的点，其必须满足以下两个条件：</p><ol><li>在这个点的电量必须能够到达最近的充电桩；</li><li>从这个点到最近的充电桩后返回这个点，它的总电量不能减少；</li></ol><p>考虑将原图缩为k个联通块，构建一张新图。</p><p>对于原图建立超级源点，点1-k向0点连边，求出距离每个非关键点最近的充电桩，以及它到最近充电桩的距离$dis[i]$。</p><p>对图上的两个非关键点$(u,v)$，点$u$能到达点$v$当且仅当电量$c$满足$(c-dis[u])-w≥dis[v]$，即$c≥dis[u]+dis[v]+w$。</p><p>对原图上的每条边更新，如果两个点$(u,v)$不属于同一个联通块，在$(belong[u],belong[v])$加边，边权为$dis[u]+dis[v]+w$。</p><p>建完新图之后，问题转化为<a href="https://loj.ac/problem/136" target="_blank" rel="noopener">最小瓶颈路</a>模板题。即给定一个k个节点m条边的图，回答q个询问，要求寻找从$s$到$t$的一条路径，使得路径上权值最大的一条边权值最小。 </p><p>这个问题离线用MST上LCA搞一下就好。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> head[maxn], dis[maxn], cnt, n, k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nex, to, w; &#125; edge[<span class="number">2</span> * maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span>&#123;</span> </span><br><span class="line"><span class="keyword">int</span> u, v, w;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> E oth) <span class="keyword">const</span> &#123; <span class="keyword">return</span> w &lt; oth.w; &#125;</span><br><span class="line">&#125; es[maxn];</span><br><span class="line"><span class="keyword">int</span> bel[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == pre[x] ? x : pre[x] = Find(pre[x]); &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">edge[++ cnt] = &#123; head[u], v, w &#125;;</span><br><span class="line">head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;, greater&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; &gt; que;</span><br><span class="line"><span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i ++) bel[i] = i, dis[i] = <span class="number">0</span>, que.push(&#123;<span class="number">0</span>, i&#125;);</span><br><span class="line"><span class="keyword">while</span>(!que.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> f = que.top(); que.pop();</span><br><span class="line"><span class="keyword">int</span> u = f.second, d = f.first;</span><br><span class="line"><span class="keyword">if</span>(d != dis[u]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i; i = edge[i].nex)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v = edge[i].to, w = edge[i].w;</span><br><span class="line"><span class="keyword">if</span>(dis[u] + w &lt; dis[v]) </span><br><span class="line">&#123;</span><br><span class="line">bel[v] = bel[u];</span><br><span class="line">dis[v] = dis[u] + w;</span><br><span class="line">que.push(&#123;dis[v], v&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> val[maxn &lt;&lt; <span class="number">1</span>], idx;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">G[u].push_back(v);</span><br><span class="line">pre[v] = u;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> dep[maxn &lt;&lt; <span class="number">1</span>], fa[maxn &lt;&lt; <span class="number">1</span>][<span class="number">30</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dep[u] = dep[pre] + <span class="number">1</span>, fa[u][<span class="number">0</span>] = pre;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= idx; i ++) fa[u][i] = fa[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> v : G[u]) <span class="keyword">if</span>(v != pre) dfs(v, u);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[u] &lt; dep[v]) swap(u, v);</span><br><span class="line"><span class="keyword">int</span> d = dep[u] - dep[v];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= d; i ++) <span class="keyword">if</span>((<span class="number">1</span> &lt;&lt; i) &amp; d) u = fa[u][i];</span><br><span class="line"><span class="keyword">if</span>(u == v) <span class="keyword">return</span> u;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">22</span>; i &gt;= <span class="number">0</span>; i --) <span class="keyword">if</span>(fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i];</span><br><span class="line"><span class="keyword">return</span> fa[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m, q, u, v, w;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>, &amp;n, &amp;m, &amp;k, &amp;q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">es[i] = &#123; u, v, w &#125;;</span><br><span class="line">add(u, v, w);</span><br><span class="line">add(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line">dij();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) <span class="keyword">if</span>(bel[es[i].u] != bel[es[i].v]) es[i].w = es[i].w + dis[es[i].u] + dis[es[i].v];</span><br><span class="line">sort(es + <span class="number">1</span>, es + m + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i ++) pre[i] = i;</span><br><span class="line">idx = k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u = bel[es[i].u], v = bel[es[i].v], w = es[i].w;</span><br><span class="line"><span class="keyword">int</span> fx = Find(u), fy = Find(v);</span><br><span class="line"><span class="keyword">if</span>(fx == fy) <span class="keyword">continue</span>;</span><br><span class="line">idx ++;</span><br><span class="line">merge(idx, fx);</span><br><span class="line">merge(idx, fy);</span><br><span class="line">val[idx] = w;</span><br><span class="line"><span class="keyword">if</span>(idx == <span class="number">2</span> * k - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">dfs(idx, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(q --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;u, &amp;v);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, val[LCA(u, v)] ? val[LCA(u, v)] : <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缩点 </tag>
            
            <tag> 最小瓶颈路 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「CodeForces-1252L」Road Construction(二分图最大匹配)</title>
      <link href="/2019/11/01/Codeforces-1252L/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://codeforces.com/contest/1252/problem/L" target="_blank" rel="noopener">L - Road Construction</a><br>给定一棵基环树上的边，每一条边可以被指定类的工人维修，求能使树上点联通的维修方案</p></blockquote><a id="more"></a><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一棵基环树上的边，每一条边可以被指定类的工人维修，求能使树上点联通的维修方案。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>如果对于边和工人一一连边，边数可能达到$NK$，考虑简化边数。</p><p>对于每组边对应的类型数$M_i$，有$\sum_{i=1}^n M_i&lt;=10000$，所以让树边与工人类型数连边，并对每种类型的工人计数，连向汇点即可。</p><p>对于一棵基环树，要选$n-1$条边使其联通，假设其环上有k条边，必须选择“环上的k-1条边”和“环外的所有边”。dfs求出基环树上的环，存储“环外的边”为A集合，“环上的边”为B集合。</p><p>首先对起点向A集合中的点连边，判断是否全部匹配；再对起点向B集合中的点连边，判断总的流量是否$&gt;=n-1$即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">int</span> pre[maxn], id[maxn];</span><br><span class="line"><span class="keyword">int</span> dfn[maxn], cnt;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; edge[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, B;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; tag;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dfn[u] = ++ cnt;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : edge[u])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v = x.first;</span><br><span class="line"><span class="keyword">if</span>(v == pre[u]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(dfn[v])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dfn[v] &lt; dfn[u]) <span class="keyword">continue</span>;</span><br><span class="line">B.push_back(x.second);</span><br><span class="line"><span class="keyword">for</span>(; v != u; v = pre[v]) B.push_back(id[v]);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">pre[v] = u;</span><br><span class="line">id[v] = x.second;</span><br><span class="line">dfs(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_V = <span class="number">10000</span> + <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> res[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dinic</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span> <span class="keyword">int</span> to, cap, rev; &#125; ;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; G[MAX_V];</span><br><span class="line"><span class="keyword">int</span> level[MAX_V];</span><br><span class="line"><span class="keyword">int</span> iter[MAX_V];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">G[from].push_back((edge)&#123;to, cap, (<span class="keyword">int</span>)G[to].size()&#125;);</span><br><span class="line">G[to].push_back((edge)&#123;from, <span class="number">0</span>, (<span class="keyword">int</span>)G[from].size() - <span class="number">1</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(level, <span class="number">-1</span>, <span class="keyword">sizeof</span> level);</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">level[s] = <span class="number">0</span>;</span><br><span class="line">que.push(s);</span><br><span class="line"><span class="keyword">while</span>(!que.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v = que.front(); que.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[v].size(); i ++)</span><br><span class="line">&#123;</span><br><span class="line">edge &amp;e = G[v][i];</span><br><span class="line"><span class="keyword">if</span>(e.cap &gt; <span class="number">0</span> &amp;&amp; level[e.to] &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">level[e.to] = level[v] + <span class="number">1</span>;</span><br><span class="line">que.push(e.to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> t, <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(v == t) <span class="keyword">return</span> f;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> &amp;i = iter[v]; i &lt; G[v].size(); i ++)</span><br><span class="line">&#123;</span><br><span class="line">edge &amp;e = G[v][i];</span><br><span class="line"><span class="keyword">if</span>(e.cap &gt; <span class="number">0</span> &amp;&amp; level[v] &lt; level[e.to])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> d = dfs(e.to, t, min(f, e.cap));</span><br><span class="line"><span class="keyword">if</span>(d &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">e.cap -= d;</span><br><span class="line">G[e.to][e.rev].cap += d;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_flow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line">bfs(s);</span><br><span class="line"><span class="keyword">if</span>(level[t] &lt; <span class="number">0</span>) <span class="keyword">return</span> flow;</span><br><span class="line"><span class="built_in">memset</span>(iter, <span class="number">0</span>, <span class="keyword">sizeof</span> iter);</span><br><span class="line"><span class="keyword">int</span> f;</span><br><span class="line"><span class="keyword">while</span>((f = dfs(s, t, inf)) &gt; <span class="number">0</span>) flow += f;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getans</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> e : G[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(e.to &lt;= n) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(e.cap == <span class="number">0</span>) res[i] = e.to - n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;dinic;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; P[maxm];</span><br><span class="line"><span class="keyword">int</span> pos[maxm];</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; e[maxn];</span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line"><span class="keyword">int</span> S = <span class="number">0</span>, T;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u, k, x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;k);</span><br><span class="line">edge[i].push_back(&#123;u, i&#125;);</span><br><span class="line">edge[u].push_back(&#123;i, i&#125;);</span><br><span class="line">e[i] = make_pair(i, u);</span><br><span class="line"><span class="keyword">while</span>(k --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"><span class="keyword">if</span>(!tag[x]) tag[x] = ++ tot;</span><br><span class="line">dinic.add(i, tag[x] + n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> v : B) vis[v] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="keyword">if</span>(!vis[i]) A.push_back(i);</span><br><span class="line">T = n + tot + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"><span class="keyword">if</span>(!tag[x]) <span class="keyword">continue</span>;</span><br><span class="line">P[tag[x]].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i ++) dinic.add(n + i, T, (<span class="keyword">int</span>)P[i].size());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : A) dinic.add(S, x, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> cur = dinic.max_flow(S, T);</span><br><span class="line"><span class="keyword">if</span>(cur &lt; A.size()) <span class="keyword">return</span> <span class="number">0</span> * <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : B) dinic.add(S, x, <span class="number">1</span>);</span><br><span class="line">cur += dinic.max_flow(S, T);</span><br><span class="line"><span class="keyword">if</span>(cur &lt; n - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span> * <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">dinic.getans();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(pos[res[i]] == P[res[i]].size()) <span class="keyword">continue</span>;</span><br><span class="line">ans[P[res[i]][pos[res[i]]]] = i;</span><br><span class="line">pos[res[i]] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i ++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(ans[i] == <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">"0 0"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, e[ans[i]].first, e[ans[i]].second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Graph </category>
          
          <category> Network Flow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dinic </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「BZOJ-3926」[Zjoi2015]诸神眷顾的幻想乡(后缀自动机)</title>
      <link href="/2019/10/31/BZOJ-3926/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3926" target="_blank" rel="noopener">BZOJ3122-[Zjoi2015]诸神眷顾的幻想乡</a></p></blockquote><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>写了cls的题当然要写题解辣！</p><p>题意相当于给了你一棵点数为$n$的树，每个点上有一个(a-j)的字符，求这颗树上所有本质不同字符串的个数（一条路径上起点与终点相反的两个串视为不同）。</p><p>由于所给的树叶子节点不超过20个，考虑以每一个叶子节点为起点进行dfs，建立广义后缀自动机，即在父节点的状态后加入子节点，然后求本质不同的字符串个数即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> col[maxn], in[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> last = <span class="number">1</span>, cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> ch[maxn &lt;&lt; <span class="number">1</span>][<span class="number">10</span>], fa[maxn &lt;&lt; <span class="number">1</span>], len[maxn &lt;&lt; <span class="number">1</span>], pos[maxn];</span><br><span class="line"><span class="keyword">int</span> sz[maxn &lt;&lt; <span class="number">1</span>], a[maxn &lt;&lt; <span class="number">1</span>], c[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = last, np = ++ cnt;</span><br><span class="line">last = np, len[np] = len[p] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; p &amp;&amp; !ch[p][c]; p = fa[p]) ch[p][c] = np;</span><br><span class="line"><span class="keyword">if</span>(!p) fa[np] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> q = ch[p][c];</span><br><span class="line"><span class="keyword">if</span>(len[p] + <span class="number">1</span> == len[q]) fa[np] = q;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nq = ++ cnt;</span><br><span class="line">len[nq] = len[p] + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="keyword">sizeof</span> ch[q]);</span><br><span class="line">fa[nq] = fa[q], fa[q] = fa[np] = nq;</span><br><span class="line"><span class="keyword">for</span>(; ch[p][c] == q; p = fa[p]) ch[p][c] = nq;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> np;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">last = p;</span><br><span class="line"><span class="keyword">int</span> q = ins(col[u]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v = G[u][i];</span><br><span class="line"><span class="keyword">if</span>(v == pre) <span class="keyword">continue</span>;</span><br><span class="line">dfs(v, u, q);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;c);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;col[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">G[u].push_back(v), G[v].push_back(u);</span><br><span class="line">in[u] ++; in[v] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="keyword">if</span>(in[i] == <span class="number">1</span>) dfs(i, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i ++) ans += len[i] - len[fa[i]];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> String </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SAM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「CodeForces-1250E」The Coronation(2-SAT)</title>
      <link href="/2019/10/29/Codeforces-1250E/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="https://codeforces.com/contest/1250/problem/E" target="_blank" rel="noopener">「CodeForces-1250E」The Coronation</a></p><p>给定一系列01串，求翻转次数最小的情况下，令任意两个串有至少k位相同的合法方案</p></blockquote><a id="more"></a><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定$n$个长度为$m$的01串，可以对任意串进行翻转，求满足任意两个串至少有k位相同的翻转方案，并使翻转次数最小。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>2-SAT问题。</p><p>设串不翻转为0，翻转为1，则对于任意两个串都有如下四种情况：</p><ol><li>a,b和a,rev(b)相同位数均大于等于k，此时a,b相互之间没有限制；</li><li>a,b相同之间位数大于等于k，a,rev(b)之间相同位数小于k，此时a,b必须相同，即XOR(a,b)=0;</li><li>a,b相同之间位数小于等于k，a,rev(b)之间相同位数大于k，此时a,b必须相反，即XOR(a,b)=1;</li><li>a,b和a,rev(b)相同位数均小于k，即无论怎么翻转都不能使a,b两者匹配；</li></ol><p>一旦出现4，整组情况一定是无解的。</p><p>相当于原串所代表的点形成若干个联通块，每一个联通块中的元素颜色是相互联系的（即如果翻转一个，必须翻转该块中的所有元素）。</p><p>建完图后对点$i$和点$i+n$进行dfs，因为图的两侧完全对称，一定会搜出一组点完全相反的两种染色方案，只要选择翻转次数较小的那一组即可。注意在dfs时需要判奇环，如果出现奇环则无解。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line">ll id[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> res[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">getid</span><span class="params">(<span class="keyword">char</span> s[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++)<span class="keyword">if</span>(s[i] - <span class="string">'0'</span>) res += (<span class="number">1l</span>l &lt;&lt; (len - i - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">(ll a, ll b)</span> </span>&#123; <span class="keyword">return</span> m - __builtin_popcountll(a ^ b); &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; g[a].push_back(b);  &#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">XOR</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(c == <span class="number">0</span>) add(a, b), add(a + n, b + n), add(b, a), add(b + n, a + n);</span><br><span class="line"><span class="keyword">else</span> add(a, b + n), add(a + n, b), add(b, a + n), add(b + n, a);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (n &lt;&lt; <span class="number">1</span>); i ++) vis[i] = res[i] =  <span class="number">0</span>, g[i].clear();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vis[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">res.push_back(u);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> v : g[u]) <span class="keyword">if</span>(!vis[v]) t += dfs(v, res);</span><br><span class="line"><span class="keyword">return</span> t + (u &gt; n);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> _;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;_);</span><br><span class="line"><span class="keyword">while</span>(_ --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">id[i] = getid(s, m);</span><br><span class="line">reverse(s, s + m);</span><br><span class="line">id[i + n] = getid(s, m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(check(id[i], id[j]) &lt; k &amp;&amp; check(id[i], id[j + n]) &lt; k) flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(check(id[i], id[j]) &gt;= k &amp;&amp; check(id[i], id[j + n]) &lt; k) XOR(i, j, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(check(id[i], id[j + n]) &gt;= k &amp;&amp; check(id[i], id[j]) &lt; k) XOR(i, j, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="keyword">if</span>(!vis[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, B;</span><br><span class="line"><span class="keyword">int</span> a = dfs(i, A);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> j : A) <span class="keyword">if</span>(j == i + n) flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> b = dfs(i + n, B);</span><br><span class="line"><span class="keyword">if</span>(a &lt; b) &#123; <span class="keyword">for</span>(<span class="keyword">auto</span> i : A) <span class="keyword">if</span>(i &gt; n) ans.push_back(i - n); &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="keyword">for</span>(<span class="keyword">auto</span> i : B) <span class="keyword">if</span>(i &gt; n) ans.push_back(i - n); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!flag) &#123; <span class="built_in">printf</span>(<span class="string">"-1\n"</span>); <span class="keyword">continue</span>; &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans.size());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : ans) <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2-SAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「UOJ-171」【WC2016】挑战NPC(一般图匹配带花树)</title>
      <link href="/2019/10/15/UOJ-171/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://uoj.ac/problem/171" target="_blank" rel="noopener">「UOJ-171」【WC2016】挑战NPC</a></p></blockquote><a id="more"></a><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有$n$个球和$m$个筐，每个球可以放入与其连边的某个筐，每个筐最多放三个球。将所有球放入筐中，筐中不超过一个球时称为「半满」，需要使半满的框数最多，并输出其中一种方案数。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>把一个筐拆成三个点，三个点之间两两连边。将可以放入某个框中的球向框的三个点连边，跑一遍带花树，$n-maxmatch$即为最大值。</p><p>因为对于某一个筐的三个点来说：球数为0时最大匹配为1，球数为1时最大匹配为2，球数为2和3时最大匹配为2。</p><p>那么对于这个筐，它对答案的贡献即为（最大匹配数-球数），输出方案即可。</p><p>注意求解时要先匹配球，否则会先匹配同一个筐与筐之间的连边，这样求出的方案就不对了orz。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[maxn];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, pre[maxn], type[maxn], link[maxn], nex[maxn], vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[u].push_back(v);</span><br><span class="line">    edge[v].push_back(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == pre[x] ? x : pre[x] = Find(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combine</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> lca)</span>    <span class="comment">//如果找到奇环，对当前点x和找到的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != lca)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = link[x], v = nex[u];</span><br><span class="line">        <span class="keyword">if</span> (Find(v) != lca) nex[v] = u;</span><br><span class="line">        <span class="keyword">if</span> (type[u] == <span class="number">1</span>) type[u] = <span class="number">2</span>, que.push(u);</span><br><span class="line">        pre[Find(x)] = Find(u);</span><br><span class="line">        pre[Find(u)] = Find(v);</span><br><span class="line">        x = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">contrack</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lca = x;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i = nex[link[i]])</span><br><span class="line">    &#123;</span><br><span class="line">        i = Find(i);</span><br><span class="line">        vis[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = y; i; i = nex[link[i]])</span><br><span class="line">    &#123;</span><br><span class="line">        i = Find(i);</span><br><span class="line">        <span class="keyword">if</span> (vis[i])</span><br><span class="line">        &#123;</span><br><span class="line">            lca = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lca != Find(x)) nex[x] = y;</span><br><span class="line">    <span class="keyword">if</span> (lca != Find(y)) nex[y] = x;</span><br><span class="line">    combine(x, lca);</span><br><span class="line">    combine(y, lca);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(type, <span class="number">0</span>, <span class="keyword">sizeof</span>(type));</span><br><span class="line">    <span class="built_in">memset</span>(nex, <span class="number">0</span>, <span class="keyword">sizeof</span>(nex));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) pre[i] = i;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) que.pop();</span><br><span class="line">    que.push(s);</span><br><span class="line">    type[s] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edge[x].size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> y = edge[x][i];</span><br><span class="line">            <span class="keyword">if</span> (Find(x) == Find(y) || link[x] == y || type[y] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (type[y] == <span class="number">2</span>) contrack(x, y);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (link[y])</span><br><span class="line">            &#123;</span><br><span class="line">                nex[y] = x;</span><br><span class="line">                type[y] = <span class="number">1</span>;</span><br><span class="line">                type[link[y]] = <span class="number">2</span>;</span><br><span class="line">                que.push(link[y]);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                nex[y] = x;</span><br><span class="line">                <span class="keyword">int</span> pos = y, u = nex[pos], v = link[u];</span><br><span class="line">                <span class="keyword">while</span> (pos)</span><br><span class="line">                &#123;</span><br><span class="line">                    link[pos] = u;</span><br><span class="line">                    link[u] = pos;</span><br><span class="line">                    pos = v;</span><br><span class="line">                    u = nex[pos];</span><br><span class="line">                    v = link[u];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxmatch</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i --) <span class="keyword">if</span> (!link[i]) bfs(i);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i --) <span class="keyword">if</span> (link[i]) ans++;</span><br><span class="line">    <span class="keyword">return</span> ans / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) edge[i].clear();</span><br><span class="line">    <span class="built_in">memset</span>(link, <span class="number">0</span>, <span class="keyword">sizeof</span>(link));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;_);</span><br><span class="line">    <span class="keyword">while</span>(_ --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> N, m, e;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;N, &amp;m, &amp;e);</span><br><span class="line">        n = <span class="number">3</span> * m + N;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span> * m; i += <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            add(i, i + <span class="number">1</span>);</span><br><span class="line">            add(i, i + <span class="number">2</span>);</span><br><span class="line">            add(i + <span class="number">1</span>, i + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="keyword">while</span>(e --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">            add(u + <span class="number">3</span> * m, (v - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">            add(u + <span class="number">3</span> * m, (v - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>);</span><br><span class="line">            add(u + <span class="number">3</span> * m, (v - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, maxmatch() - N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> + <span class="number">3</span> * m; i &lt;= n; i ++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, (link[i] - <span class="number">1</span>) / <span class="number">3</span> + <span class="number">1</span>, <span class="string">" \n"</span>[i == n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一般图匹配 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「2018 EC-Final」J - Philosophical … Balance(SAM+纳什均衡)</title>
      <link href="/2019/10/15/GYM-102056/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="https://codeforces.com/gym/102056/problem/J" target="_blank" rel="noopener">「 2018-2019 ACM-ICPC, Asia East Continent Finals 」J - Philosophical … Balance</a></p></blockquote><a id="more"></a><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个字符串，先手给串的每一个位置赋一个值$p_i$并保证$p_i \ge 0, \sum_{i=1}^n p_i = 1$，后手选择一个子串$j$。有式子$\sum_{k=1}^n p_k \mathrm{lcp}(s_k,s_j)$，先手想使其尽可能大，后手想使其尽可能小。先手要如何操作才能使这个值最大，求这个最大值。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>看了<a href="https://www.cnblogs.com/mangoyang/p/10476902.html" target="_blank" rel="noopener">这篇题解</a>，网友是真的牛逼（战术后仰）</p><p>将原串反向，建立后缀自动机。<br>对于反串的后缀树，此时后手如果选择某个子树$u$中选择串$s_j$，在$p$固定的情况下要使lcp最小，显然最优解为选择子树的根。</p><p>在后缀自动机的suffix link树中，如果当前state为np节点，则直接取当前节点的len作为答案。否则需要合并若干子树的答案，答案为一个纳什均衡的模型，即每个子节点的贡献相等。那么该点的贡献为$len[u]+x$，其中$len[u]$一定会取到，$x$为纳什均衡下可以取到的最大值，推一下子树的$x$得到$x = \frac{1}{\sum \frac{1}{f_i}}$，那么在suffix link树上dfs即可求出答案。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SuffixAutomation</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> last, cnt;</span><br><span class="line"><span class="keyword">int</span> ch[maxn &lt;&lt; <span class="number">1</span>][<span class="number">26</span>], fa[maxn &lt;&lt; <span class="number">1</span>], len[maxn &lt;&lt; <span class="number">1</span>], pos[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> sz[maxn &lt;&lt; <span class="number">1</span>], a[maxn &lt;&lt; <span class="number">1</span>], c[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i ++) g[i].clear();</span><br><span class="line">    last = cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(ch[<span class="number">1</span>], <span class="number">0</span>, <span class="keyword">sizeof</span> ch[<span class="number">1</span>]);</span><br><span class="line">    fa[<span class="number">1</span>] = len[<span class="number">1</span>] = sz[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="keyword">inline</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">++cnt;</span><br><span class="line"><span class="built_in">memset</span>(ch[cnt], <span class="number">0</span>, <span class="keyword">sizeof</span> ch[cnt]);</span><br><span class="line">fa[cnt] = len[cnt] = sz[cnt] = <span class="number">0</span>;</span><br><span class="line">pos[cnt] = idx;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = last , np = newnode(pos[last] + <span class="number">1</span>);</span><br><span class="line">last = np, len[np] = len[p] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; p &amp;&amp; !ch[p][c]; p = fa[p]) ch[p][c] = np;</span><br><span class="line"><span class="keyword">if</span>(!p) fa[np] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> q = ch[p][c];</span><br><span class="line"><span class="keyword">if</span>(len[p] + <span class="number">1</span> == len[q]) fa[np] = q;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nq = newnode(pos[p] + <span class="number">1</span>);</span><br><span class="line">len[nq] = len[p] + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="keyword">sizeof</span> ch[q]);</span><br><span class="line">fa[nq] = fa[q], fa[q] = fa[np] = nq;</span><br><span class="line"><span class="keyword">for</span>(; ch[p][c] == q; p = fa[p]) ch[p][c] = nq;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        sz[np] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">suffixTree</span><span class="params">()</span> </span>&#123; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cnt; i ++) g[fa[i]].push_back(i); &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sz[u]) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : g[u]) res += <span class="number">1.0</span> / dfs(v, len[v] - len[u]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> / res + l;</span><br><span class="line">&#125;</span><br><span class="line">&#125;sam;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;_);</span><br><span class="line">    <span class="keyword">while</span>(_ --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">        sam.init();</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) sam.ins(s[i] - <span class="string">'a'</span>);</span><br><span class="line">        sam.suffixTree();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.10f\n"</span>, sam.dfs(<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> String </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博弈 </tag>
            
            <tag> 后缀自动机 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「CodeForces-919E」Congruence Equation(费马小定理)</title>
      <link href="/2019/08/29/Codeforces-919E/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="https://codeforces.com/contest/919/problem/E" target="_blank" rel="noopener">「CodeForces-919E」Congruence Equation</a></p><p>给定a,b,n,p，求关于n的方程n⋅a^n≡b(mod p)在[1,x]中整数解的数量</p></blockquote><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>对原式$k \cdot a^k \equiv b \quad (\textrm{mod}\;p)$，考虑消去指数。由费马小定理，对质数$p$，有$a^{(p-1)} \equiv 1 \quad (\textrm{mod}\;p)$。</p><p>令$k=x\cdot(p-1)+y$，则原式转化为</p><p>$$(x\cdot(p-1)+y)\cdot a^{x\cdot(p-1)+y} \equiv b \quad (\textrm{mod}\;p)$$</p><p>$$(x\cdot(p-1)+y)\cdot a^{y} \equiv b \quad (\textrm{mod}\;p)$$</p><p>$$x\cdot(p-1)+y \equiv b \cdot a^{-y}\quad (\textrm{mod}\ p)$$</p><p>$$x\equiv y-b \cdot a^{-y}\quad (\textrm{mod}\ p)$$</p><p>问题转化为求$x\equiv y-b \cdot a^{-y}\quad (\textrm{mod}\ p)$在$(x\cdot(p-1)+y)∈[1,n]$中解的个数。</p><p>枚举$y∈[0,p-2]$，计算$x$的个数，其中若$x,y$均为0时$n=0$，需要减去。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll a, b, n, p;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a, ll n = p - <span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; n; n &gt;&gt;= <span class="number">1</span>, (a *= a) %= p) <span class="keyword">if</span>(n &amp; <span class="number">1</span>) (res *= a) %= p;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; p &gt;&gt; n;</span><br><span class="line">    ll inva = inv(a), res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; p - <span class="number">1</span>; y ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// x = y - b * a ^ (-y) + k * p</span></span><br><span class="line">        ll x = (y - b + p) % p;</span><br><span class="line">        <span class="keyword">if</span>(y &lt;= n &amp;&amp; (n - y) / (p - <span class="number">1</span>) &gt;= x)</span><br><span class="line">        &#123;</span><br><span class="line">            res += ((n - y) / (p - <span class="number">1</span>) - x) / p + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) res --;</span><br><span class="line">        &#125;</span><br><span class="line">        (b *= inva) %= p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 费马小定理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「UVALive-7264」Kejin Game(最小割)</title>
      <link href="/2019/08/22/UVALive-7264/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=5276" target="_blank" rel="noopener">「LA-7264」Kejin Game</a><br>最小割模型，到达给定点所需的最小花费</p></blockquote><a id="more"></a><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>游戏内有一个技能树（为DAG），每个技能有一些前置技能，必须先学习完前置技能才能学习当前技能。</p><p>你是一个氪金玩家。你可以选择氪金跳过所有前置技能直接学习某个技能；或者氪金切断A到B的边，使技能A不再是B的前置技能（也就意味着学习技能B不再需要先学技能A），并且在学习完所有仍然存在的前置技能（可能为0）后，花费正常的价格学习当前技能。</p><p>求习得某个技能$S$所需的最小花费。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>对于技能$i$，有两种方式习得该技能：</p><ol><li>直接氪金习得该技能</li><li>切断一些前置技能的边，习得剩下的前置技能(同样可以通过1,2两种方式)，并且花费正常价格学习当前技能</li></ol><p>考虑拆点，令点$i+n$为学习技能$i$的最小花费。</p><p>对$i$和$i+n$连边，容量为氪金学习该技能的花费；</p><p>对$S$和$i$连边，容量为正常价格学习该技能的花费；</p><p>对$j+n$和$i$连边，其中$j$为$i$的前置技能，容量为切断$j-i$的花费。</p><p>那么$S$到$i+n$的最小割即为”氪金直接学习当前技能“与”切断一部分前置技能，学习剩下的前置技能，正常学习当前技能“的花费当中的较小值。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_V = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于表示边的结构体（终点，流量，反向边）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> to, cap, rev;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; G[MAX_V];<span class="comment">//图的邻接表表示</span></span><br><span class="line"><span class="keyword">int</span> level[MAX_V];<span class="comment">//顶点到源点的距离标号</span></span><br><span class="line"><span class="keyword">int</span> iter[MAX_V];<span class="comment">//当前弧</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">G[from].push_back((edge)&#123;to, cap, G[to].size()&#125;);</span><br><span class="line">G[to].push_back((edge)&#123;from, <span class="number">0</span>, G[from].size() - <span class="number">1</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算从源点出发的距离标号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(level, <span class="number">-1</span>, <span class="keyword">sizeof</span>(level));</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">level[s] = <span class="number">0</span>;</span><br><span class="line">que.push(s);</span><br><span class="line"><span class="keyword">while</span>(!que.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v = que.front(); que.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[v].size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">edge &amp;e = G[v][i];</span><br><span class="line"><span class="keyword">if</span>(e.cap &gt; <span class="number">0</span> &amp;&amp; level[e.to] &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">level[e.to] = level[v] + <span class="number">1</span>;</span><br><span class="line">que.push(e.to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过DFS寻找增广路</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> t, <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(v == t) <span class="keyword">return</span> f;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> &amp;i = iter[v]; i&lt;G[v].size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">edge &amp;e = G[v][i];</span><br><span class="line"><span class="keyword">if</span>(e.cap &gt; <span class="number">0</span> &amp;&amp; level[v] &lt; level[e.to])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> d = dfs(e.to, t, min(f, e.cap));</span><br><span class="line"><span class="keyword">if</span>(d &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">e.cap -= d;</span><br><span class="line">G[e.to][e.rev].cap += d;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求解从s到t的最大流</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_flow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line">bfs(s);</span><br><span class="line"><span class="keyword">if</span>(level[t] &lt; <span class="number">0</span>) <span class="keyword">return</span> flow;</span><br><span class="line"><span class="built_in">memset</span>(iter, <span class="number">0</span>, <span class="keyword">sizeof</span>(iter));</span><br><span class="line"><span class="keyword">int</span> f;</span><br><span class="line"><span class="keyword">while</span>((f = dfs(s,t,INF)) &gt; <span class="number">0</span>) flow += f;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _, n, m, p, a, b, c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;_);</span><br><span class="line">    <span class="keyword">while</span>(_ --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;p);</span><br><span class="line">        <span class="keyword">int</span> S = <span class="number">0</span>, T = <span class="number">2</span> * n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= T; i ++) G[i].clear();</span><br><span class="line">        <span class="keyword">while</span>(m --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">            add(a + n, b, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c), add(S, i, c);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c), add(i, i + n, c);</span><br><span class="line">        add(p + n, T, INF);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, max_flow(S, T));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Graph </category>
          
          <category> Network Flow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小割 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「HDU-6661」Acesrc and String Theory (后缀数组)</title>
      <link href="/2019/08/21/HDU-6661/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6661" target="_blank" rel="noopener">「HDU-6661」Acesrc and String Theory</a><br>给定一个串，问由k个循环节组成的子串数量</p></blockquote><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑找到一个由循环节构成的联通块。枚举循环节长度$i∈(1,n/2)$，找到区间$[L,R]$为某个循环节长度为$i$的极大循环节（向右能够扩展的长度小于$i$），求得$extR=lcp(s(L),s(R+1))$为该串可以向右扩展的最大长度，并翻转原串求出向左扩展的最大长度$extL=lcp(revs(n+1-R), revs(n+1-L+1))$，那么求出的块为$[l,r]$为$[L-extL,R+extR]$。当前块对答案的贡献为“长度为$r-l+1$的串中长度为$k×i$的子串个数”，即$(r-l+1)-k×i+1$。</p><p>当$k=1​$时需要特判。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> s[maxn];</span><br><span class="line">    <span class="keyword">int</span> sa[maxn], t[maxn], t2[maxn], c[maxn], n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build_sa</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> *x = t, *y = t2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) c[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) c[x[i] = s[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) sa[--c[x[i]]] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = n - k; i &lt; n; i++) y[p++] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span>(sa[i] &gt;= k) y[p++] = sa[i] - k;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) c[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) c[x[y[i]]]++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) sa[--c[x[y[i]]]] = y[i];</span><br><span class="line">            swap(x, y);</span><br><span class="line">            p = <span class="number">1</span>; x[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">                x[sa[i]] = y[sa[i - <span class="number">1</span>]] == y[sa[i]] &amp;&amp; y[sa[i - <span class="number">1</span>] + k] == y[sa[i] + k] ? p - <span class="number">1</span> : p++;</span><br><span class="line">            <span class="keyword">if</span>(p &gt;= n) <span class="keyword">break</span>;</span><br><span class="line">            m = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rk[maxn], height[maxn];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getHeight</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) rk[sa[i]] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k) k--;</span><br><span class="line">            <span class="keyword">int</span> j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span>(s[i + k] == s[j + k]) k++;</span><br><span class="line">            height[rk[i]] = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; i --) rk[i] = rk[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dp[maxn][<span class="number">21</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RMQ</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) dp[i][<span class="number">0</span>] = height[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt; maxn; j ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i ++)</span><br><span class="line">                dp[i][j] = min(dp[i][j - <span class="number">1</span>], dp[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((<span class="number">1</span> &lt;&lt; (k + <span class="number">1</span>)) &lt;= r - l + <span class="number">1</span>) k ++;</span><br><span class="line">        <span class="keyword">return</span> min(dp[l][k], dp[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lcp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = rk[x], y = rk[y];</span><br><span class="line">        <span class="keyword">if</span>(x &gt; y) swap(x, y);</span><br><span class="line">        <span class="keyword">return</span> query(x + <span class="number">1</span>, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;A, B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> exR = A.lcp(l, r + <span class="number">1</span>), exL = B.lcp(n + <span class="number">1</span> - r, n + <span class="number">1</span> - l + <span class="number">1</span>);</span><br><span class="line">    l -= exL, r += exR;</span><br><span class="line">    <span class="keyword">return</span> max(<span class="number">0</span>, r - l + <span class="number">1</span> - p * k + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;_);</span><br><span class="line">    <span class="keyword">while</span>(_ --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%s"</span>, &amp;k, A.s);</span><br><span class="line">        n = <span class="built_in">strlen</span>(A.s);</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, <span class="number">1l</span>l * n * (n + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse_copy(A.s, A.s + n, B.s); A.n = B.n = n;</span><br><span class="line">        A.build_sa(n + <span class="number">1</span>, <span class="number">130</span>), B.build_sa(n + <span class="number">1</span>, <span class="number">130</span>);</span><br><span class="line">        A.getHeight(), B.getHeight();</span><br><span class="line">        A.RMQ(), B.RMQ();</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> last = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j += i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(A.lcp(last, j) &gt;= i) <span class="keyword">continue</span>;</span><br><span class="line">                ans += work(last, j - <span class="number">1</span>, i);</span><br><span class="line">                <span class="keyword">if</span>(j + i - <span class="number">1</span> &lt;= n) last = j;</span><br><span class="line">                <span class="keyword">else</span> last = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(last) ans += work(last, n, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> String </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后缀数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「LightOJ-1428」Melody Comparison(后缀数组)</title>
      <link href="/2019/08/14/Lightoj-1428/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://lightoj.com/volume_showproblem.php?problem=1428" target="_blank" rel="noopener">「LightOJ-1428」Melody Comparison</a><br>给定串A和串B，求串A本质不同且不包含串B的子串个数。</p></blockquote><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>KMP预处理出串A的每个后缀向右延伸的最远的不包含串B的位置<code>rmax[i]</code>。那么对于后缀<code>sa[i]</code>，它的不包含串B的前缀个数为<code>rmax[sa[i]]</code>个。因为要求本质不同的子串个数，需要减去当前后缀和上一个后缀相同的前缀个数<code>height[i]</code>。答案即为$ans=\sum_{i=1}^nrmax[sa[i]]-min(height[i],rmax[i])$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[maxn], b[maxn];</span><br><span class="line"><span class="keyword">int</span> sa[maxn], t[maxn], t2[maxn], c[maxn], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_sa</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *x = t, *y = t2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) c[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) c[x[i] = s[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) sa[--c[x[i]]] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - k; i &lt; n; i++) y[p++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span>(sa[i] &gt;= k) y[p++] = sa[i] - k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) c[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) c[x[y[i]]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) sa[--c[x[y[i]]]] = y[i];</span><br><span class="line">        swap(x, y);</span><br><span class="line">        p = <span class="number">1</span>; x[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            x[sa[i]] = y[sa[i - <span class="number">1</span>]] == y[sa[i]] &amp;&amp; y[sa[i - <span class="number">1</span>] + k] == y[sa[i] + k] ? p - <span class="number">1</span> : p++;</span><br><span class="line">        <span class="keyword">if</span>(p &gt;= n) <span class="keyword">break</span>;</span><br><span class="line">        m = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rk[maxn], height[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getHeight</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) rk[sa[i]] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k) k--;</span><br><span class="line">        <span class="keyword">int</span> j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(s[i + k] == s[j + k]) k++;</span><br><span class="line">        height[rk[i]] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) ++sa[i], rk[i] = rk[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rmax[maxn], nex[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(b), i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line">    nex[i] = j;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">-1</span> || b[i] == b[j]) nex[++ i] = ++ j;</span><br><span class="line">        <span class="keyword">else</span> j = nex[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KMP</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s), m = <span class="built_in">strlen</span>(b), i = <span class="number">0</span>, j = <span class="number">0</span>, pos = <span class="number">1</span>;</span><br><span class="line">    getNext();</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">-1</span> || s[i] == b[j]) i ++, j ++;</span><br><span class="line">        <span class="keyword">else</span> j = nex[j];</span><br><span class="line">        <span class="keyword">if</span>(j == m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> p = pos; p &lt;= i - m + <span class="number">1</span>; p ++) rmax[p] = i - p;</span><br><span class="line">            j = nex[j], pos = i - m + <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pos &lt;= n) rmax[pos] = n - pos + <span class="number">1</span>, pos ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> _ = <span class="number">1</span>; _ &lt;= T; _ ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, s, b);</span><br><span class="line">        n = <span class="built_in">strlen</span>(s);</span><br><span class="line">        KMP();</span><br><span class="line">        build_sa(n + <span class="number">1</span>, <span class="number">130</span>);</span><br><span class="line">        getHeight();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) res += rmax[sa[i]] - min(rmax[sa[i]], height[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %lld\n"</span>, _, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> String </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP </tag>
            
            <tag> 后缀数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「BZOJ-3105」[cqoi2013]新Nim游戏(博弈+线性基)</title>
      <link href="/2019/08/03/BZOJ-3105/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3105" target="_blank" rel="noopener">BZOJ3105-[cqoi2013]新Nim游戏</a><br>有n堆火柴堆，先手和后手可以依次取走若干堆火柴堆（不能全部取走），然后进行Nim游戏，先手如何取才能保证必胜，并在保证胜利的情况下使他取的火柴总数最小。</p></blockquote><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><blockquote><p>标准的Nim游戏中，只要是所有火柴堆的火柴数目异或值为0，那么先手必败，否则先手必胜。</p></blockquote><p>在取完前两轮后这个游戏就是个标准的Nim博弈。那么在先手取完后，后手一定会取走若干个火柴堆，使剩下的异或和为0。</p><p>那么对于先手，应该取走若干个火柴堆，使剩下的火柴堆不存在异或和为0的子集，也就是使剩下的火柴堆成为一个线性极大无关组。</p><p>又因为要使先手所取的火柴总数最小，我们把火柴堆从大到小排序，依次插入线性基，不能插入线性基的元素就是先手要取的火柴堆。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((x &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i]) x ^= d[i];</span><br><span class="line">            <span class="keyword">else</span> &#123; d[i] = x; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, a[<span class="number">105</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    sort(a, a + n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) <span class="keyword">if</span>(!ins(a[i])) res += a[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性基 </tag>
            
            <tag> 博弈 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「BZOJ-4568」[Scoi2016]幸运数字(倍增+线性基)</title>
      <link href="/2019/08/02/BZOJ-4568/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4568" target="_blank" rel="noopener">BZOJ4568-[Scoi2016]幸运数字</a><br>在树上路径(u,v)之间选择一些点的权值，使异或和最大</p></blockquote><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>对于树上的每一个点，维护log(n)个线性基，L[u][i]表示从它自身到它上跳$2^i$倍祖先的线性基，在对LCA做预处理的时候预处理出单个节点的倍增线性基。查询LCA时每次上跳都对答案插入当前节点上跳$2^i$倍的线性基，最后要单独插入点$a[v]$的值。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, dep[maxn], fa[maxn][<span class="number">20</span>]; ll a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinearBasis</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll d[<span class="number">64</span>], tot;</span><br><span class="line"></span><br><span class="line">    LinearBasis()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">63</span>; i &gt;= <span class="number">0</span>; i --) <span class="keyword">if</span>((x &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i]) x ^= d[i];</span><br><span class="line">            <span class="keyword">else</span> &#123; d[i] = x; tot ++; <span class="keyword">return</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">max_xor</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">63</span>; i &gt;= <span class="number">0</span>; i --) <span class="keyword">if</span>((ans ^ d[i]) &gt; ans) ans ^= d[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(LinearBasis &amp;a)</span> </span>&#123; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">63</span>; i &gt;= <span class="number">0</span>; i --) <span class="keyword">if</span>(a.d[i]) ins(a.d[i]); &#125;</span><br><span class="line">&#125;L[maxn][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">LinearBasis <span class="title">merge</span><span class="params">(<span class="keyword">const</span> LinearBasis &amp;a, <span class="keyword">const</span> LinearBasis &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinearBasis res = a;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">63</span>; i &gt;= <span class="number">0</span>; i --) <span class="keyword">if</span>(b.d[i]) res.ins(b.d[i]);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[u] = dep[pre] + <span class="number">1</span>, fa[u][<span class="number">0</span>] = pre;</span><br><span class="line">    L[u][<span class="number">0</span>].ins(a[pre]); L[u][<span class="number">0</span>].ins(a[u]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        fa[u][i] = fa[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        L[u][i].Merge(L[u][i - <span class="number">1</span>]);</span><br><span class="line">        L[u][i].Merge(L[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edge[u].size(); i ++) &#123;<span class="keyword">int</span> v = edge[u][i]; <span class="keyword">if</span>(v != pre) dfs(v, u); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LinearBasis <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinearBasis res;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &lt; dep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">int</span> d = dep[u] - dep[v];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= d; i ++) <span class="keyword">if</span>((<span class="number">1</span> &lt;&lt; i) &amp; d) res.Merge(L[u][i]), u = fa[u][i];</span><br><span class="line">    <span class="keyword">if</span>(u == v) &#123; res.ins(a[v]); <span class="keyword">return</span> res; &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i --) <span class="keyword">if</span>(fa[u][i] != fa[v][i]) res.Merge(L[u][i]), res.Merge(L[v][i]), u = fa[u][i], v = fa[v][i];</span><br><span class="line">    res.Merge(L[u][<span class="number">0</span>]), res.ins(a[v]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q, u, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        edge[u].push_back(v);</span><br><span class="line">        edge[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(q --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        LinearBasis ans = LCA(u, v);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans.max_xor());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCA </tag>
            
            <tag> 线性基 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「BZOJ-3122」[Sdoi2013]随机数生成器(BSGS)</title>
      <link href="/2019/08/02/BZOJ-3122/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3122" target="_blank" rel="noopener">BZOJ3122-[Sdoi2013]随机数生成器</a><br>有递推式X(i+1)=(aX(i)+b) mod p， 求最小的i使X(i)=t</p></blockquote><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>$$X_i=aX_{i-1}+b$$</p><p>$$\ \quad=a^2X_{i-2}+ab+b​$$</p><p>$$=…$$</p><p>$$\ \quad=a^{i-1}X_{1}+a^{i-2}b+a^{i-1}b+…+ab+b​$$</p><p>$$\ \quad=a^{i-1}X_{1}+b{a^{i-1}-1 \over a-1}​$$</p><p>又$X_i=t$，有$$a^{i-1}X_1+b{a^{i-1}-1 \over a-1}≡t \ mod \ p$$</p><p>其中只有$a_{i-1}$为未知量，对其化简得</p><p>$$a^{i-1}≡{(a-1)t+b \over (a-1)x_1+b} \ mod \ p​$$</p><p>其中$i$为题目要我们求的答案。</p><p>首先特判几种情况：</p><p>①$a=0$时，原式为$X_i=b$，若$t=b$，则$i=1$；否则无解，输出-1；</p><p>②$a=1$时，若$b=0$，分式分母为0，无解，输出-1；否则原式为$X_i=X_1+(i-1)b$，对$i$化简有$i={t-x_1 \over b}+1$，逆元求解即可；</p><p>③$X_1=t$时，有$a^{i-1}=1$，此时易得$i=1​$；</p><p>如果不存在上述情况，对于式子</p><p>$$a^{i-1}≡{(a-1)t+b \over (a-1)x_1+b} \ mod \ p$$</p><p>两边同乘$a$，有式子$$a^i≡a{(a-1)t+b \over (a-1)x_1+b} \ mod \ p$$</p><p>BSGS即可求出$i$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> n, <span class="keyword">int</span> mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>, base = a % mod;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>) (ans *= base) %= mod;</span><br><span class="line">        (base *= base) %= mod;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">return</span> qp(a, p - <span class="number">2</span>, p); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BSGS</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">    b %= p;</span><br><span class="line">    <span class="keyword">int</span> t = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(p) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>; j &lt; t; j ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">1l</span>l * b * qp(a, j, p) % p;</span><br><span class="line">        hash[val] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    a = qp(a, t, p);</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">0</span>) <span class="keyword">return</span> b == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> val = qp(a, i, p);</span><br><span class="line">        <span class="keyword">int</span> j = hash.find(val) == hash.end() ? <span class="number">-1</span> : hash[val];</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= <span class="number">0</span> &amp;&amp; i * t - j &gt;= <span class="number">0</span>) <span class="keyword">return</span> i * t - j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _, p, a, b, x, t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;_);</span><br><span class="line">    <span class="keyword">while</span>(_ --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld%lld"</span>, &amp;p, &amp;a, &amp;b, &amp;x, &amp;t);</span><br><span class="line">        <span class="keyword">if</span>(x == t) &#123; <span class="built_in">puts</span>(<span class="string">"1"</span>); <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t == b ? <span class="number">2</span> : <span class="number">-1</span>); <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">1</span>) &#123;<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, b ? ((((t - x) % p + p) % p) * inv(b, p) % p + <span class="number">1</span>) : <span class="number">-1</span>); <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp = b * inv(a - <span class="number">1</span>, p) % p;</span><br><span class="line">        <span class="keyword">int</span> y = (t + tmp) % p * inv((x + tmp) % p, p) % p * a % p;</span><br><span class="line">        <span class="keyword">int</span> ans = BSGS(a, y, p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BSGS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「HDU-6579」Operation (线性基)</title>
      <link href="/2019/07/22/HDU-6579/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6579" target="_blank" rel="noopener">「HDU-6579」Operation</a><br>贪心+线性基，在LR区间内取任意个元素，求最大异或和</p></blockquote><a id="more"></a><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个长度为n的序列，有如下两种操作：</p><ol><li>求L,R区间内任意个元素的最大异或和；</li><li>在序列末尾插入一个元素；</li></ol><p>本题强制在线。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑对每个点维护一个线性基，插入操作为继承上一个点的线性基并插入当前点的值。</p><p>维护每个基底组成的点g[i]，考虑贪心，尽可能使组成线性基的点更靠近R。</p><p>对于某一位的点g[i]，如果pos&gt;g[i]，则把pos与g[i]交换，使pos成为线性基的基底。</p><p>对于每个询问，查询第R个线性基所有pos大于L的基底能组成的最大值。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getpos</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> lasans)</span> </span>&#123; <span class="keyword">return</span> (x ^ lasans) % n + <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinearBasis</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">30</span>], g[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">29</span>; ~i; i --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((x &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(f[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(g[i] &lt;= pos) &#123; x ^= f[i]; f[i] ^= x; swap(g[i], pos); &#125;</span><br><span class="line">                    <span class="keyword">else</span> x ^= f[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; f[i] = x; g[i] = pos; <span class="keyword">break</span>; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">29</span>; ~i; i --) <span class="keyword">if</span>(g[i] &gt;= l) res = max(res, res ^ f[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;base[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, q, op, l, r, x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            base[i] = base[i - <span class="number">1</span>];</span><br><span class="line">            base[i].ins(x, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(q --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;op);</span><br><span class="line">            <span class="keyword">if</span>(op == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">                l = getpos(l, ans), r = getpos(r, ans);</span><br><span class="line">                <span class="keyword">if</span>(l &gt; r) swap(l, r);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans = base[r].query(l));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); n ++;</span><br><span class="line">                base[n] = base[n - <span class="number">1</span>], base[n].ins(x ^ ans, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性基 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「BZOJ-2242」[SDOI2011]计算器 (BSGS)</title>
      <link href="/2019/07/19/BZOJ-2242/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2242" target="_blank" rel="noopener">BZOJ2242 - [SDOI2011]计算器</a></p></blockquote><a id="more"></a><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定三个数$y,z,p$，进行如下三种操作：</p><p>1.计算Y^Z Mod P 的值<br>2.计算满足xy≡ Z ( mod P )的最小非负整数<br>3.计算满足Y^x ≡ Z ( mod P)的最小非负整数</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>虽然我确实在找板题，但这种纯板题为什么会出现在OI省选……</p><p><em>op1：快速幂</em></p><p><em>op2：exgcd</em></p><p><em>op3：BSGS</em></p><p>都套板子就vansˊ_&gt;ˋ </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> n, <span class="keyword">int</span> mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>, base = a;</span><br><span class="line"><span class="keyword">while</span>(n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n &amp; <span class="number">1</span>) (ans *= base) %= mod;</span><br><span class="line">(base *= base) %= mod;</span><br><span class="line">n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) &#123; x = <span class="number">1</span>; y = <span class="number">0</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">    exgcd(b, a % b, x, y);</span><br><span class="line">    <span class="keyword">int</span> t = x; x = y, y = t - a / b * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BSGS</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">b %= p;</span><br><span class="line"><span class="keyword">int</span> t = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(p) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>; j &lt; t; j ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> val = <span class="number">1l</span>l * b * qp(a, j, p) % p;</span><br><span class="line">hash[val] = j;</span><br><span class="line">&#125;</span><br><span class="line">a = qp(a, t, p);</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">0</span>) <span class="keyword">return</span> b == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> val = qp(a, i, p);</span><br><span class="line"><span class="keyword">int</span> j = hash.find(val) == hash.end() ? <span class="number">-1</span> : hash[val];</span><br><span class="line"><span class="keyword">if</span>(j &gt;= <span class="number">0</span> &amp;&amp; i * t - j &gt;= <span class="number">0</span>) <span class="keyword">return</span> i * t - j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, k, y, z, p;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;t, &amp;k);</span><br><span class="line">    <span class="keyword">while</span>(t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;y, &amp;z, &amp;p);</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, qp(y, z, p));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x, xx;</span><br><span class="line">            exgcd(y, p, x, xx);</span><br><span class="line">            x = <span class="number">1l</span>l * x * z % p;</span><br><span class="line">            <span class="keyword">if</span>(x) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (x % p + p) % p);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"Orz, I cannot find x!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = BSGS(y, z, p);</span><br><span class="line">            <span class="keyword">if</span>(~ans) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"Orz, I cannot find x!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 扩展欧几里得算法 </tag>
            
            <tag> BSGS </tag>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019牛客暑期多校训练营（第一场） - H XOR（线性基）</title>
      <link href="/2019/07/19/Nowcoder-Multi-University-2019-Round1-H/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="https://ac.nowcoder.com/acm/contest/881/H" target="_blank" rel="noopener">H-XOR</a><br>给定一个集合，求它异或和为0的子集的大小总和</p></blockquote><a id="more"></a><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定$n$个数${a_i}$，求它异或和为0的子集的大小总和。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑求集合中的每个元素对答案的贡献。</p><p>设$a$中不在线性基中的集合$S(|S|=n-|B|)$，它的任意一个子集的异或和一定可以表示为线性基中若干个数的异或和。对于某个不在线性基中的元素$a_i$，包含它的集合$S$的子集数量为$2^{n-|B|-1}$个。</p><p>对于线性基中的某个二进制位$x$，如果有一个不在线性基内的数$a_j$满足<code>(1&lt;&lt;x)&amp;a[j]==1</code>，则表示原本为这一位基底的$a_i$可以被$a_j$替换，并构成一个新的线性基$B’$,此时视$a_i$为在线性基外的元素，其对答案的贡献为$2^{n-|B|-1}$。</p><p>最后的答案为$$ans=(n-|B|+cnt)×2^{n-|B|-1}$$，其中$cnt$表示线性基中能被替换的向量个数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qp</span><span class="params">(ll a, ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;n ; (a *= a) %= mod, n &gt;&gt;= <span class="number">1</span>) <span class="keyword">if</span>(n &amp; <span class="number">1</span>) (ans *= a) %= mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll v;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinearBasis</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ll d[<span class="number">63</span>], o[<span class="number">63</span>];   <span class="comment">//原矩阵，对角矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i ++) d[i] = o[i] = <span class="number">0</span>;</span><br><span class="line">v = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ins</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">62</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((x &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!d[i]) d[i] = x, o[i] = tmp | (<span class="number">1l</span>l &lt;&lt; i), flag = <span class="literal">true</span>;</span><br><span class="line">x ^= d[i]; tmp ^= o[i];</span><br><span class="line"><span class="keyword">if</span>(!x) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!flag) v |= tmp;</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line">&#125;L;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        L.init();</span><br><span class="line">        ll x, ans = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x);</span><br><span class="line">            <span class="keyword">if</span>(!L.ins(x)) ans ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">63</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(L.d[i]) cnt ++;</span><br><span class="line">            <span class="keyword">if</span>((<span class="number">1l</span>l &lt;&lt; i) &amp; v) ans ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans * qp(<span class="number">2</span>, n - cnt - <span class="number">1</span>) % mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性基 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「CodeForces-1195F」Geometers Anonymous Club(闵可夫斯基和)</title>
      <link href="/2019/07/18/Codeforces-1195F/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="https://codeforces.com/contest/1195/problem/F" target="_blank" rel="noopener">「CodeForces-1195F」Geometers Anonymous Club</a></p><p>给定n个凸包，求第l个到第r个凸包的Minkowski和</p></blockquote><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>求凸包之间的闵可夫斯基和：取出两个凸包的每一条向量，按照极角序排序构成新凸包即可。（相同斜率的向量需要去重）<br>求多个凸包的闵可夫斯基和的时候可以直接取所有凸包的向量，不同向量的个数就是求和之后凸包的点数。</p><p>所以原问题转化为，在第l到r个凸包的向量中，有多少个互不相同的向量。</p><p>考虑对向量按凸包从左到右依次编号，标记当前向量上一次出现的位置（如果是第一次出现则pre[i]=0）。离线处理答案，按向量编号从小到大顺序扫描向量集，对向量<code>i</code>上一次出现的位置<code>pre[i]</code>的出现次数计数，用树状数组维护。对于某一个询问Q的L和R，如果存在<code>L&lt;=i&lt;=r</code>且<code>L&lt;=pre[i]&lt;=r</code>，说明该向量在LR区间内重复出现。对于右端点为R的询问LR，它的答案为L到R的凸包的向量总数-LR区间内重复出现的向量个数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> x[maxn], y[maxn], tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> pre[maxn], pos[maxn], ans[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; query[maxn];</span><br><span class="line"><span class="keyword">int</span> data[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i ++; i &lt; maxn; i += i &amp; -i) data[i] += y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i ++; i; i -= i &amp; -i) res += data[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; , <span class="keyword">int</span>&gt; pre_idx;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        pos[i] = tot;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j ++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x[j], &amp;y[j]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p(x[(j + <span class="number">1</span>) % k] - x[j], y[(j + <span class="number">1</span>) % k] - y[j]);</span><br><span class="line">            <span class="keyword">int</span> g = __gcd(<span class="built_in">abs</span>(p.first), <span class="built_in">abs</span>(p.second));</span><br><span class="line">            p.first /= g, p.second /= g;</span><br><span class="line">            pre[tot] = pre_idx[p];</span><br><span class="line">            pre_idx[p] = tot ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pos[n] = tot ++;</span><br><span class="line">    <span class="keyword">int</span> q, l, r, x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">        ans[i] = pos[r] - pos[-- l];</span><br><span class="line">        query[pos[r]].push_back(&#123;pos[l], i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> q : query[i])</span><br><span class="line">        &#123;</span><br><span class="line">            l = q.first, x = q.second;</span><br><span class="line">            ans[x] -= sum(i) - sum(l - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        add(pre[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i ++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Geometry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
            <tag> 闵可夫斯基和 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「HDU-6532」Chessboard (费用流)</title>
      <link href="/2019/05/29/HDU-6532/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6532" target="_blank" rel="noopener">「HDU-6532」Chessboard</a><br>离散化+二分图行列模型，求限制条件下放置棋子的最大总价值</p></blockquote><a id="more"></a><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个棋盘，可以在给定的位置放棋子，第i个棋子的价值为i。并给出若干个限制条件，要求在某列右侧/某行下方的棋子总数不超过$k_i$，求满足限制条件情况下放置棋子可以获得的最大价值。</p><p><em>XTU教练：这不就是个费用流吗.jpg(震声）</em></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>二分图的行列模型，数据范围需要离散化。第0行为源点，第0列为汇点；第$i-1$行向第$i$行连边，流量为第$i$行的限制；第$i$列向第$i-1$列连边，流量为第$i$列的限制，并将每个点所在的行向其所在的列连边，流量为1，费用为$-i$，跑费用流即可。</p><p>需要注意建图的时候只离散化给定的点的行和列的点作为网络上的点，对于每一个限制条件lower_bound找到第一个大于等于它的点，并更新该点的限制，最后对于lim_R[i]和lim_C[i]建图。</p><p><del>其实我赛场上就嘴出解法了然后因为是嘴巴选手所以敲了1h没写出来</del></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> <span class="keyword">int</span> from, to, cap, flow,cost; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line">    <span class="keyword">bool</span> inq[maxn];</span><br><span class="line">    <span class="keyword">int</span> dis[maxn], path[maxn], a[maxn];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) G[i].clear();</span><br><span class="line">        edges.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap, <span class="keyword">int</span> cost)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        edges.push_back(Edge&#123;from, to, cap, <span class="number">0</span>, cost&#125;);</span><br><span class="line">        edges.push_back(Edge&#123;to, from, <span class="number">0</span>, <span class="number">0</span>, -cost&#125;);</span><br><span class="line">        m = edges.size();</span><br><span class="line">        G[from].push_back(m - <span class="number">2</span>);</span><br><span class="line">        G[to].push_back(m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Bellman_Ford</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> &amp;flow, <span class="keyword">int</span> &amp;cost)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) dis[i] = inf;</span><br><span class="line">        <span class="built_in">memset</span>(inq, <span class="number">0</span>, <span class="keyword">sizeof</span> inq);</span><br><span class="line">        dis[s] = <span class="number">0</span>, inq[s] = <span class="literal">true</span>, path[s] = <span class="number">0</span>, a[s] = inf;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        Q.push(s);</span><br><span class="line">        <span class="keyword">while</span>(!Q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front(); Q.pop();</span><br><span class="line">            inq[u] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i ++)</span><br><span class="line">            &#123;</span><br><span class="line">                Edge&amp; e = edges[G[u][i]];</span><br><span class="line">                <span class="keyword">if</span>(e.cap &gt; e.flow &amp;&amp; dis[e.to] &gt; dis[u] + e.cost)</span><br><span class="line">                &#123;</span><br><span class="line">                    dis[e.to] = dis[u] + e.cost;</span><br><span class="line">                    path[e.to] = G[u][i];</span><br><span class="line">                    a[e.to] = min(a[u], e.cap - e.flow);</span><br><span class="line">                    <span class="keyword">if</span>(!inq[e.to])</span><br><span class="line">                    &#123;</span><br><span class="line">                        Q.push(e.to);</span><br><span class="line">                        inq[e.to] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dis[t] == inf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        flow += a[t];</span><br><span class="line">        cost += dis[t] * a[t];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u = t; u != s; u = edges[path[u]].from)</span><br><span class="line">        &#123;</span><br><span class="line">            edges[path[u]].flow += a[t];</span><br><span class="line">            edges[path[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mincostMaxFlow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cost = <span class="number">0</span>, flow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(Bellman_Ford(s, t, flow, cost));</span><br><span class="line">        <span class="keyword">return</span> cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> LR[maxn], LC[maxn];</span><br><span class="line"><span class="keyword">int</span> mp[<span class="number">510</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; posR, posC;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, pos, k;</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;mp[i][<span class="number">0</span>], &amp;mp[i][<span class="number">1</span>]);</span><br><span class="line">        posR.push_back(mp[i][<span class="number">0</span>]);</span><br><span class="line">        posC.push_back(mp[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    posR.push_back(<span class="number">0</span>);</span><br><span class="line">    posC.push_back(<span class="number">0</span>);</span><br><span class="line">    sort(posR.begin(), posR.end());</span><br><span class="line">    sort(posC.begin(), posC.end());</span><br><span class="line">    posR.erase(unique(posR.begin(), posR.end()), posR.end());</span><br><span class="line">    posC.erase(unique(posC.begin(), posC.end()), posC.end());</span><br><span class="line">    <span class="built_in">memset</span>(LR, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> LR);</span><br><span class="line">    <span class="built_in">memset</span>(LC, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> LC);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>, op, &amp;pos, &amp;k);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'R'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pos = lower_bound(posR.begin(), posR.end(), pos) - posR.begin();</span><br><span class="line">            LR[pos] = min(LR[pos], k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'C'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pos = lower_bound(posC.begin(), posC.end(), pos) - posC.begin();</span><br><span class="line">            LC[pos] = min(LC[pos], k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> S = <span class="number">0</span>, T = posR.size();</span><br><span class="line">    ans.init(posR.size() + posC.size());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; posR.size(); i ++) ans.addEdge(i - <span class="number">1</span>, i, LR[i], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; posC.size(); i ++) ans.addEdge(i + posR.size(), i + posR.size() - <span class="number">1</span>, LC[i], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = lower_bound(posR.begin(), posR.end(), mp[i][<span class="number">0</span>]) - posR.begin(),</span><br><span class="line">            y = lower_bound(posC.begin(), posC.end(), mp[i][<span class="number">1</span>]) - posC.begin() + posR.size();</span><br><span class="line">        ans.addEdge(x, y, <span class="number">1</span>, - i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, -ans.mincostMaxFlow(S, T));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Graph </category>
          
          <category> Network Flow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 费用流 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「HDU-6285」Vertex Cover (计数)</title>
      <link href="/2019/05/09/HDU-6285/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6285" target="_blank" rel="noopener">「HDU-6285」Vertex Cover</a></p></blockquote><a id="more"></a><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个$n$个点的完全图，第$i$个点的点权为$2^{i-1}$。给定一个边集，对于一个点集，要求边集中的每一条边至少有一个端点在点集中，并保证点集的权值和最小。现在给一个点集，问有多少种满足条件的边集。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们令在点集中的点为关键点，不在点集中的点为非关键点，满足条件的边集中的<strong>关键点</strong>$u$连接情况满足以下条件：</p><p>​    在编号大于$u$的点中，至少有一个<strong>非关键点</strong>与$u$相连。</p><p>简单证明一下这个条件。</p><p>考虑反证法，假设与关键点$u$相连的点编号全部小于$u$，由于点权编码的性质，$10000&gt;01111$，此时即使将所有比它小的关键点选中，权值和仍然小于选择$u$的花费，所以这时$u$不可能是关键点。因此，必然至少有一个大于$u$的点$v$与$u$相连。</p><p>为什么点$v$至少需要有一个非关键点。同样考虑反证法，假设与$u$相连的点集$v$全为关键点，那么以$u$为端点的边已经全部被选取，为了使点权和最小化，这时候不需要选取$u$，因此这种情况下$u$不是关键点。</p><p>此时可以推出在编号大于$u$的点中，至少有一个<strong>非关键点</strong>与$u$相连。</p><p>满足这个条件的连边方式可以保证所给的点集是权值和最小的取点方案。在满足该条件后，关键点可以向其余点任意连边，因为从关键点出发的边已经被覆盖，且选取其它点的权值和必然大于选择该点。为了避免重复计数，对于关键点$u$，我们只向小于$u$的点统计连边方案。</p><p>因此对于每个关键点，连边满足以下条件：</p><ol><li>在编号大于$u$的点中，至少有一个<strong>非关键点</strong>与$u​$相连；</li><li>在满足条件1的情况下，对于编号小于$u​$的点，可以有任意个点与点$u​$相连；</li></ol><p>最后的式子为$$\prod_{i\in{set}}2^{i-1}·(2^{cnt({v&gt;i}\bigcap{v\notin{set}})}-1)​$$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>嘴巴选手写什么代码我有空再补咕咕咕</p>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Counting </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计数原理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「HDU-6059」Kanade&#39;s trio (Trie树)</title>
      <link href="/2019/04/20/HDU-6059/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6059" target="_blank" rel="noopener">「HDU-6059」Kanade’s trio </a><br>给定一个序列，求序列中满足i&lt;j&lt;k且(A[i] xor A[j])&lt;(A[j] xor A[k])的三元组的数量</p></blockquote><a id="more"></a><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个长度为$n(∑n≤5∗10^5)$的序列，求序列中满足$i&lt;j&lt;k$且$(A[i]\ xor\ A[j])&lt;(A[j]\ xor\ A[k])$的三元组的数量，其中$0≤A[i]&lt;2^{30}$.</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>对于每个数进行二进制拆分，依次插入字典树处理。</p><p>首先考虑两个数$A[i],A[k]$，其二进制位前若干位相等，第$p$位不同。此时若要选取满足条件的数$A[j]$，则$A[j]$的前$p-1$位取任意值都不影响结果，而对于第$p$位，要使$(A[i]\ xor\ A[j])&lt;(A[j]\ xor\ A[k])$，有如下两种情况：</p><ul><li>$A[i]_p=1, A[k]_p=0​$，此时$A[j]_p​$取值为$1​$</li><li>$A[i]_p=0, A[k]_p=1$，此时$A[j]_p$取值为$0$</li></ul><p>即$A[j]_p$的取值为$A[j]_p=A[i]_p$</p><p>具体到插入字典树的过程中，对于$A[k]$插入过程中的每一位，判断是否存在二进制位为$!A[k]_p$的字典树节点$pos=trie[now][!A[k]_p]$，如果有，在计数过程中考虑如下两种情况：</p><ol><li><p>$i,j$均为结点$pos$子树下的节点：</p><p>此时方案数为$C\binom{2}{sz[pos]} = sz[pos]×(sz[pos]-1)/2$，其中$sz[pos]$表示结点$pos$的子树大小，该选取方案可以保证$i,j$有序；</p></li><li><p>$i$为结点$pos$子树下的节点，$j$为不在结点$pos$下，且第$p$位二进制数与$i$相同的节点：</p><p>利用数组$cnt[p][2]​$统计第$p​$个二进制位上为0/1的数的数量，当前方案数即为$(cnt[p][!A[k]_p]-sz[pos])×sz[pos]​$，但注意这种计数方案没有保证$i&gt;j​$的方案数；</p><p>我们考虑一个数$A[i]$，在当前位$p$插入字典树时，有$cnt[p][A[i]_p]-sz[pos]$个数在选取时满足$j&lt;i$的情况，对该值求和即为在统计该节点$pos$时需要减去的方案数。</p><p>故第二种情况的方案数为$(cnt[p][!A[k]_p]-sz[pos])×sz[pos]-sum[pos]$，其中$sum$为$pos$位插入过程中$cnt[p][A[i]_p]-sz[pos]$的和；</p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">31</span> *(<span class="number">5e5</span> + <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> trie[maxn][<span class="number">2</span>], tot;</span><br><span class="line"><span class="keyword">int</span> sz[maxn], ext[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">31</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(trie, <span class="number">0</span>, <span class="keyword">sizeof</span> trie);</span><br><span class="line">    <span class="built_in">memset</span>(sz, <span class="number">0</span>, <span class="keyword">sizeof</span> sz);</span><br><span class="line">    <span class="built_in">memset</span>(ext, <span class="number">0</span>, <span class="keyword">sizeof</span> ext);</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">    ans = tot = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_ch</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">29</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> id = (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!trie[root][id]) trie[root][id] = ++tot;</span><br><span class="line">        cnt[i][id]++;</span><br><span class="line">        <span class="keyword">if</span>(trie[root][id ^ <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> now = trie[root][id ^ <span class="number">1</span>];</span><br><span class="line">            ans += <span class="number">1l</span>l * sz[now] * (sz[now] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            ans += <span class="number">1l</span>l * (cnt[i][<span class="number">1</span> ^ id] - sz[now]) * sz[now] - ext[now];</span><br><span class="line">        &#125;</span><br><span class="line">        root = trie[root][id];</span><br><span class="line">        sz[root]++;</span><br><span class="line">        ext[root] += cnt[i][id] - sz[root];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, n, x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            insert_ch(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> String </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Trie树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「BZOJ-4774」修路 (斯坦纳树)</title>
      <link href="/2019/04/17/BZOJ-4774/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4774" target="_blank" rel="noopener">BZOJ4774-修路</a><br>在图上选中一些边，使给定的点对能通过选中的边连通，最小化选中的边的权值和</p></blockquote><a id="more"></a><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="斯坦纳树"><a href="#斯坦纳树" class="headerlink" title="斯坦纳树"></a>斯坦纳树</h3><p>将指定点集合中的所有点连通，且边权总和最小的生成树称为最小斯坦纳树（Minimal Steiner Tree）。</p><p>斯坦纳树可以通过dp求解，转移方程有两种：</p><ol><li>枚举子树形态 $dp[S][i] = min(dp[s]+dp[S \ xor \  s])$</li><li>按照边进行松弛 $dp[S][i] = min(dp[S][j]+w[j][i])$</li></ol><p>其中$S$为选取的子集，$s$ 和$S\ xor\ s$为$S$的状态划分。第二类转移方程可以通过跑一次最短路进行松弛。</p><p>本题需要再做一次子集dp，因为不成对的点可能不连通。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[maxn], cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> nex, to, w; &#125;edge[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].nex = head[u];</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1</span>&lt;&lt;<span class="number">10</span>][maxn], ans[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">bool</span> in[maxn];</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = que.front(); que.pop();</span><br><span class="line">        in[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].nex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(f[S][v] &gt; f[S][u] + edge[i].w)</span><br><span class="line">            &#123;</span><br><span class="line">                f[S][v] = f[S][u] + edge[i].w;</span><br><span class="line">                <span class="keyword">if</span>(!in[v]) que.push(v), in[v] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Steiner_Tree</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; i++)</span><br><span class="line">        f[<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>)][i] = f[<span class="number">1</span> &lt;&lt; (d + i - <span class="number">1</span>)][n - i + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lim = <span class="number">1</span>&lt;&lt;(d&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">1</span>; S &lt; lim; S++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> s = (S - <span class="number">1</span>) &amp; S; s; s = (s - <span class="number">1</span>) &amp; S)</span><br><span class="line">                f[S][i] = min(f[S][i], f[s][i] + f[S ^ s][i]);</span><br><span class="line">            <span class="keyword">if</span>(f[S][i] != inf) que.push(i), in[i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        spfa(S);</span><br><span class="line">    &#125;</span><br><span class="line">    lim = <span class="number">1</span>&lt;&lt;d;</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> ans);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">1</span>; S &lt; lim; S++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            ans[S] = min(ans[S], f[S^(S&lt;&lt;d)][i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> S = <span class="number">1</span>; S &lt; lim; S++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s = (S - <span class="number">1</span>) &amp; S; s; s = (s - <span class="number">1</span>) &amp; S)</span><br><span class="line">            ans[S] = min(ans[S], ans[s] + ans[S ^ s]);</span><br><span class="line">    <span class="keyword">return</span> ans[lim - <span class="number">1</span>] == inf ? <span class="number">-1</span> : ans[lim - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, d, u, v, w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;d);</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0xff</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        add(u, v, w);</span><br><span class="line">        add(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Steiner_Tree(n, d));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 斯坦纳树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「HDU-2121」Ice_cream’s world II(不定根最小树形图)</title>
      <link href="/2019/03/27/HDU-2121/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2121" target="_blank" rel="noopener">「HDU-2121」Ice_cream’s world II</a><br>朱刘算法，不定根最小树形图</p></blockquote><a id="more"></a><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个有向图，选择一个点使其能到达其他所有点，并使花费最小，输出最小花费。如果有多个这样的点，输出编号小的点。如果没有这样的点，输出impossible.</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>不定根最小生成树模板题。</p><p>设定一个虚根并向所有结点连边，边权为图上所有边的边权之和$sum+1$，以虚根为$root$跑一遍朱刘算法。</p><p>如果求出的边权之和$res&gt;=2*sum$，说明至少有两个结点是从虚根出发到达的点，即原图不连通。</p><p>原图连通的状态下，只有一个点是从虚根出发到达的点。在跑最小树形图时记录从虚根出发到达的点，即为原图的根。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> INF = <span class="number">1e17</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> u, v; <span class="keyword">long</span> <span class="keyword">long</span> cost; &#125; edge[maxn * maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre[maxn], vis[maxn], id[maxn], pos;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> in[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">zhuliu</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) in[i] = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">if</span> (edge[i].u != edge[i].v &amp;&amp; edge[i].cost &lt; in[edge[i].v])</span><br><span class="line">            &#123;</span><br><span class="line">                pre[edge[i].v] = edge[i].u;</span><br><span class="line">                in[edge[i].v] = edge[i].cost;</span><br><span class="line">                <span class="keyword">if</span> (edge[i].u == root) pos = i;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span> (i != root &amp;&amp; in[i] == INF) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> tn = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(id, <span class="number">0xff</span>, <span class="keyword">sizeof</span> id);</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0xff</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">        in[root] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res += in[i];</span><br><span class="line">            v = i;</span><br><span class="line">            <span class="keyword">while</span> (vis[v] != i &amp;&amp; id[v] == <span class="number">-1</span> &amp;&amp; v != root) vis[v] = i, v = pre[v];</span><br><span class="line">            <span class="keyword">if</span> (v != root &amp;&amp; id[v] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> u = pre[v]; u != v; u = pre[u]) id[u] = tn;</span><br><span class="line">                id[v] = tn++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tn == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span> (id[i] == <span class="number">-1</span>) id[i] = tn++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            v = edge[i].v;</span><br><span class="line">            edge[i].u = id[edge[i].u];</span><br><span class="line">            edge[i].v = id[edge[i].v];</span><br><span class="line">            edge[i].cost -= in[v];</span><br><span class="line">        &#125;</span><br><span class="line">        n = tn;</span><br><span class="line">        root = id[root];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>, &amp;edge[i].u, &amp;edge[i].v, &amp;edge[i].cost);</span><br><span class="line">            edge[i].u++;</span><br><span class="line">            edge[i].v++;</span><br><span class="line">            sum += edge[i].cost;</span><br><span class="line">        &#125;</span><br><span class="line">        sum++;</span><br><span class="line">        <span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt; m + n; i++)</span><br><span class="line">            edge[i].u = root, edge[i].v = i - m + <span class="number">1</span>, edge[i].cost = sum;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = zhuliu(root, n + <span class="number">1</span>, m + n);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">-1</span> || res - sum &gt;= sum) <span class="built_in">printf</span>(<span class="string">"impossible\n\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld %d\n\n"</span>, res - sum, pos - m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小树形图 </tag>
            
            <tag> 朱刘算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「HDU-6141」I am your Father!(最小树形图)</title>
      <link href="/2019/03/27/HDU-6141/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6141" target="_blank" rel="noopener">「HDU-6141」I am your Father! </a><br>求最大树形图，并最小化点n​父亲结点的编号</p></blockquote><a id="more"></a><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个有向图，求出以1为根的最大树形图，如果有多个，则使$n$结点的父亲节点编号最小。输出边权和$W$和点$n$的父亲节点。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于$W$，可以直接对边权取负，跑一遍朱刘算法。</p><p>为使点$n$的父亲节点编号最小，需要对连向点$n$的边进行加权操作，并且需要保证加权后的权值不会影响原图。</p><p>对于原图上的边，对边权*1000，而加权操作加上的权值为起始点$u$的编号(不超过1000)，即可保证在不影响原结果的情况下，求出父节点编号最小的解。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> u,v,cost; &#125; edge[maxm];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre[maxn], id[maxn], vis[maxn], in[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zhuliu</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>, u, v;</span><br><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) in[i] = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) <span class="keyword">if</span>(edge[i].u != edge[i].v &amp;&amp; edge[i].cost &lt; in[edge[i].v])</span><br><span class="line">&#123;</span><br><span class="line">pre[edge[i].v] = edge[i].u;</span><br><span class="line">in[edge[i].v] = edge[i].cost;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="keyword">if</span>(i != root &amp;&amp; in[i] ==INF) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> tn=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(id, <span class="number">0xff</span>, <span class="keyword">sizeof</span> id);</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0xff</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">in[root] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">res += in[i];</span><br><span class="line">v = i;</span><br><span class="line"><span class="keyword">while</span>( vis[v] != i &amp;&amp; id[v] == <span class="number">-1</span> &amp;&amp; v!= root) vis[v] = i, v = pre[v];</span><br><span class="line"><span class="keyword">if</span>(v != root &amp;&amp; id[v] == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u = pre[v]; u != v; u = pre[u]) id[u] = tn;</span><br><span class="line">id[v] = tn++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tn == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="keyword">if</span>(id[i] == <span class="number">-1</span>) id[i] = tn++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m;)</span><br><span class="line">&#123;</span><br><span class="line">v = edge[i].v;</span><br><span class="line">edge[i].u = id[edge[i].u];</span><br><span class="line">edge[i].v = id[edge[i].v];</span><br><span class="line"><span class="keyword">if</span>(edge[i].u != edge[i].v) edge[i++].cost -= in[v];</span><br><span class="line"><span class="keyword">else</span> swap(edge[i], edge[--m]);</span><br><span class="line">&#125;</span><br><span class="line">n = tn;</span><br><span class="line">root = id[root];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, n, m, u, v, w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;edge[i].u, &amp;edge[i].v, &amp;edge[i].cost);</span><br><span class="line">            edge[i].u--;</span><br><span class="line">            edge[i].v--;</span><br><span class="line">            edge[i].cost = -edge[i].cost * <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].v == n - <span class="number">1</span>) edge[i].cost += edge[i].u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = -zhuliu(<span class="number">0</span>, n, m);</span><br><span class="line">        <span class="keyword">int</span> ans = (res + <span class="number">999</span>) / <span class="number">1000</span>, pos = ans * <span class="number">1000</span> - res;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, ans, pos + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小树形图 </tag>
            
            <tag> 朱刘算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「POJ-3417」Network (LCA+树上差分)</title>
      <link href="/2019/03/22/POJ-3417/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://poj.org/problem?id=3417" target="_blank" rel="noopener">「POJ-3417」Network </a><br>LCA+树上差分，给定一棵树和一些附加边，在其中各删一条使树不连通，求可行的方案数。</p></blockquote><a id="more"></a><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一棵树和一些附加边，要求在原始边和附加边中各选一条删除，从而使树被分割为至少两个联通块，求可行的方案数。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于每个给出的附加边求LCA，树上差分，标记其所在的环上的所有边的经过次数。</p><p>对于树上每条边的经过次数：</p><ol><li><p>$cnt[i]=0:$ 不属于任何环，此时只要删除该边和任意一条附加边即可，方案数$+m;$</p></li><li><p>$cnt[i]=1:$ 只属于一个环，删除该边和属于该环的附加边为可行解，方案数$+1;$</p></li><li><p>$cnt[i]&gt;1:$该边属于多个环，需要删除该边和所在所有边上的附加环才可分割该图，删该树边不存在可行解。</p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> nex,to; &#125;edge[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,head[maxn],dep[maxn],fa[maxn][<span class="number">30</span>],cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++cnt].nex=head[u];</span><br><span class="line">    edge[cnt].to=v;</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[u]=dep[pre]+<span class="number">1</span>;</span><br><span class="line">    fa[u][<span class="number">0</span>]=pre;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=n;i++) fa[u][i]=fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=edge[i].nex) <span class="keyword">if</span>(edge[i].to!=pre) dfs(edge[i].to,u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&lt;dep[v]) swap(u,v);</span><br><span class="line">    <span class="keyword">int</span> d=dep[u]-dep[v];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=d;i++) <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&amp;d) u=fa[u][i];</span><br><span class="line">    <span class="keyword">if</span>(u==v) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[u][i]!=fa[v][i])</span><br><span class="line">        &#123;</span><br><span class="line">            u=fa[u][i];</span><br><span class="line">            v=fa[v][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sta[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=edge[i].nex) <span class="keyword">if</span>(edge[i].to!=pre) sta[u]+=dfs1(edge[i].to,u);</span><br><span class="line">    <span class="keyword">return</span> sta[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,u,v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">        add(u,v); add(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">        <span class="keyword">int</span> root=LCA(u,v);</span><br><span class="line">        sta[u]++; sta[v]++;</span><br><span class="line">        sta[root]-=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sta[i]==<span class="number">0</span>) ans+=m;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sta[i]==<span class="number">1</span>) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCA </tag>
            
            <tag> 树上差分 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「BZOJ-3940&amp;3942」Censoring (字符串)</title>
      <link href="/2019/03/20/BZOJ-3940-3942/"/>
      <content type="html"><![CDATA[<blockquote><p>给定一个字符串S，给定一个模式串/n个模式串，从前往后寻找，一旦找到模式串，删除该模式串并继续从头寻找。重复这一过程，直到S中不存在模式串，输出最后的S。</p></blockquote><a id="more"></a><p>好了这是Usaco月赛里面题意和做法都非常相似的两个题，分别是KMP和AC自动机的应用。</p><h1 id="Sliver"><a href="#Sliver" class="headerlink" title="Sliver"></a>Sliver</h1><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3942" target="_blank" rel="noopener">BZOJ3942 - [Usaco2015 Feb]Censoring</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出两个字符串 $S$ 和 $T$，每次从前往后找到$S$ 的一个子串 $A=T$并将其删除，空缺位依次向前补齐，重复上述操作多次，直到串$S$中不含 $T$串。输出最终的$S$串。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用栈维护给定的$S$串，对$s$依次入栈并求当前位的$next$数组，如果匹配到$T$，将长度为$len(T)$的字符出栈。对于每个入栈元素，取当前栈顶元素即可求出当前元素的$next$数组指向位置，直到$S$全部入栈。输出栈内元素即为答案。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[maxn], b[maxn], st[maxn];</span><br><span class="line"><span class="keyword">int</span> nex[maxn], p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(b), i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line">    nex[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; b[i] != b[j + <span class="number">1</span>]) j = nex[j];</span><br><span class="line">        <span class="keyword">if</span> (b[i] == b[j + <span class="number">1</span>])</span><br><span class="line">            j++;</span><br><span class="line">        nex[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KMP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(a), m = <span class="built_in">strlen</span>(b);</span><br><span class="line">    getNext();</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = p[top];</span><br><span class="line">        st[++top] = a[i];</span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; b[j + <span class="number">1</span>] != st[top]) j = nex[j];</span><br><span class="line">        <span class="keyword">if</span> (b[j + <span class="number">1</span>] == st[top])</span><br><span class="line">            j++;</span><br><span class="line">        p[top] = j;</span><br><span class="line">        <span class="keyword">if</span> (p[top] + <span class="number">1</span> == m)</span><br><span class="line">            top -= m;</span><br><span class="line">    &#125;</span><br><span class="line">    st[top + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">puts</span>(st + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, a, b);</span><br><span class="line">    KMP();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Gold"><a href="#Gold" class="headerlink" title="Gold"></a>Gold</h1><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3940" target="_blank" rel="noopener">BZOJ3940 - [Usaco2015 Feb]Censoring</a></p><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给定一个串$S$和$n$个屏蔽词$T_n$，对于串$S$，每次从前往后检查并删除最先出现的屏蔽词，重复该操作直到$S$中没有列表内的单词为止。完成这些操作并输出最后的$S$。</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>同样由栈维护母串$S$，并记录栈中每个字符在Trie树上的位置，如果遇到关键串，将该串推出栈中，每次入栈前取当前栈顶字符在Trie树上的位置即可求出当前串的位置。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[maxn], t[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ACAutomation</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> trie[maxn][<span class="number">26</span>], cnt;</span><br><span class="line">    <span class="keyword">int</span> tag[maxn];</span><br><span class="line">    <span class="keyword">int</span> fail[maxn];</span><br><span class="line">    <span class="keyword">int</span> st[maxn], pos[maxn], cur;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = s[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (!trie[root][id])</span><br><span class="line">                trie[root][id] = ++cnt;</span><br><span class="line">            root = trie[root][id];</span><br><span class="line">        &#125;</span><br><span class="line">        tag[root] = <span class="built_in">strlen</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (trie[<span class="number">0</span>][i])</span><br><span class="line">                que.push(trie[<span class="number">0</span>][i]);</span><br><span class="line">        <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (trie[k][i]) &#123;</span><br><span class="line">                    fail[trie[k][i]] = trie[fail[k]][i];</span><br><span class="line">                    que.push(trie[k][i]);</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    trie[k][i] = trie[fail[k]][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line">        pos[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; t[i]; i++) &#123;</span><br><span class="line">            root = trie[pos[cur]][t[i] - <span class="string">'a'</span>];</span><br><span class="line">            st[++cur] = t[i] - <span class="string">'a'</span>;</span><br><span class="line">            pos[cur] = root;</span><br><span class="line">            <span class="keyword">if</span> (tag[root]) &#123;</span><br><span class="line">                cur -= tag[root];</span><br><span class="line">                root = pos[cur];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cur; i++) <span class="built_in">printf</span>(<span class="string">"%c"</span>, st[i] + <span class="string">'a'</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; AC;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, t);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">        AC.insert(s);</span><br><span class="line">    &#125;</span><br><span class="line">    AC.build();</span><br><span class="line">    AC.query();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> String </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP </tag>
            
            <tag> AC自动机 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「BZOJ-2115」[Wc2011] Xor (线性基)</title>
      <link href="/2019/01/18/BZOJ-2115/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2115" target="_blank" rel="noopener">BZOJ3732-[Wc2011] Xor</a><br>给定一个无向图，求节点1到结点N的XOR和最大路径，一条边可以重复经过多次。</p></blockquote><a id="more"></a><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>由于路径可以重复经过，对于图上的任意一个环，可以选择取或不取该环的值，而对于点1-n的路径异或和最大值，可以视为某一条1-n的路径，异或上若干个环的路径长度的最大值。</p><p>预处理求出图上所有环的异或和，并任取一条1-n的路径异或和，对这些值求线性基，即可求出最大值。</p><p>为什么1-n的路径可以任取：假设1-n有大于一条路径，其中另一条路径与所有环异或能取得更优解，那么此时可视为有一个经过1和n的环，故直接将该环与原所取路径异或即可取得最大值。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[maxn],cnt=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> nex,to; ll w; &#125;edge[<span class="number">20</span>*maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,ll w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].nex=head[u];</span><br><span class="line">    edge[cnt].to=v;</span><br><span class="line">    edge[cnt].w=w;</span><br><span class="line">    head[u]=cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,ll w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    add_edge(u,v,w);</span><br><span class="line">    add_edge(v,u,w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll _xor[maxn],a[<span class="number">5</span>*maxn],tot=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];~i;i=edge[i].nex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!vis[v])</span><br><span class="line">        &#123;</span><br><span class="line">            _xor[v]=_xor[u]^edge[i].w;</span><br><span class="line">            vis[v]=<span class="literal">true</span>;</span><br><span class="line">            dfs(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            a[tot++]=_xor[u]^_xor[v]^edge[i].w;</span><br><span class="line">            <span class="keyword">if</span>(!a[tot<span class="number">-1</span>]) tot--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll b[<span class="number">70</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="keyword">sizeof</span> b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">63</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;&gt;j&amp;<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(b[j]) a[i]^=b[j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    b[j]=a[i];</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=j<span class="number">-1</span>;k&gt;=<span class="number">0</span>;k--) <span class="keyword">if</span>(b[k]&amp;&amp;(b[j]&gt;&gt;k&amp;<span class="number">1</span>)) b[j]^=b[k];</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>;k&lt;=<span class="number">63</span>;k++) <span class="keyword">if</span>(b[k]&gt;&gt;j&amp;<span class="number">1</span>) b[k]^=b[j];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,u,v;</span><br><span class="line">    ll w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0xff</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        add(u,v,w);</span><br><span class="line">    &#125;</span><br><span class="line">    _xor[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    cal();</span><br><span class="line">    ll ans=_xor[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">63</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span>(ans&lt;(ans^b[i])) ans^=b[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性基 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Codeforces Round 525 (Div. 2)</title>
      <link href="/2018/12/26/Codeforces%20Round%20525%20(Div.%202)/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://codeforces.com/contest/1088" target="_blank" rel="noopener">Codeforces Round #525 (Div. 2) </a></p></blockquote><a id="more"></a><h1 id="A-Ehab-and-another-construction-problem"><a href="#A-Ehab-and-another-construction-problem" class="headerlink" title="A. Ehab and another construction problem"></a>A. Ehab and another construction problem</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,x,x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-Ehab-and-subtraction"><a href="#B-Ehab-and-subtraction" class="headerlink" title="B. Ehab and subtraction"></a>B. Ehab and subtraction</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    sort(a,a+n);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n&amp;&amp;cnt&lt;k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[i]-tmp);</span><br><span class="line">        tmp=a[i];</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n&amp;&amp;a[i]==tmp) i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(cnt&lt;k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-Ehab-and-a-2-operation-task"><a href="#C-Ehab-and-a-2-operation-task" class="headerlink" title="C. Ehab and a 2-operation task"></a>C. Ehab and a 2-operation task</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个长度为$n$的序列，有如下两种操作：</p><ul><li><p>将序列中的前$i$个数加上$x$</p></li><li><p>将序列中的前$i$个数模$x$</p></li></ul><p>要求使用不多于$n+1$次操作，使该序列变为<strong>严格递增</strong>。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>构造一个模$n+1$答案为1,2,3……n的序列即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a[maxn];</span><br><span class="line">    <span class="keyword">int</span> x[maxn];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=(a[i]+sum)%(n+<span class="number">1</span>);</span><br><span class="line">        x[i]=i-tmp;</span><br><span class="line">        <span class="keyword">if</span>(x[i]&lt;<span class="number">0</span>) x[i]+=n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x[i]) cnt++;</span><br><span class="line">        sum+=x[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(x[i]) <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>,<span class="number">1</span>,i+<span class="number">1</span>,x[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"2 %d %d\n"</span>,n,n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-Ehab-and-another-another-xor-problem"><a href="#D-Ehab-and-another-another-xor-problem" class="headerlink" title="D. Ehab and another another xor problem"></a>D. Ehab and another another xor problem</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>交互题。</p><p>有两个数$a,b$，对于每次询问<code>? c d</code>，返回<code>cmp(a^c,b^d)</code>的值，要求在62次询问之内求出$a,b$的值，其中$0≤a,b&lt;2^{30}$.</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>考虑二进制分解，从最高位向下求解。</p><p>假设前k位已经确定，对于第k位的值，询问<code>(1,0)</code>,<code>(0,1)</code>,有如下情况：</p><ul><li><p>如果$a[k],b[k]$均为0，则<code>ask(1,0)=1</code>,<code>ask(0,1)=-1</code></p></li><li><p>如果$a[k],b[k]$均为1，则<code>ask(1,0)=-1</code>,<code>ask(0,1)=1</code></p></li><li><p>如果$a[k]≠b[k]$，则两次返回的值相同，且所得值为后k+1位的比较结果；</p><p>对于这种情况，需要在开始时<code>ask(0,0)</code>比较$a,b$后k位的大小，并根据比较的返回值更新该值。</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"? %d %d\n"</span>,a,b);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>,x,y;</span><br><span class="line">    <span class="keyword">int</span> big=query(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">29</span>;~i;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        x=query(a^(<span class="number">1</span>&lt;&lt;i),b);</span><br><span class="line">        y=query(a,b^(<span class="number">1</span>&lt;&lt;i));</span><br><span class="line">        <span class="keyword">if</span>(x==y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(big==<span class="number">1</span>) a^=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            <span class="keyword">else</span> b^=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            big=x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">-1</span>) a^=(<span class="number">1</span>&lt;&lt;i),b^=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"! %d %d\n"</span>,a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-Ehab-and-a-component-choosing-problem"><a href="#E-Ehab-and-a-component-choosing-problem" class="headerlink" title="E. Ehab and a component choosing problem"></a>E. Ehab and a component choosing problem</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给定一个有$n$个结点的树，每个节点的点权为$a_u$.选定k个不相交的联通块，使$\frac{\sum\limits_{u \in s} a_u}{k}$的值最大，如果有多个解，最大化k的值。</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>如果不需要最大化k的值，显然取k=1，最大联通块的值$w$即为所求解。</p><p>对于k&gt;1的情况，只要求出值等于$w$的联通块数量即可求解。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> val[maxn],head[maxn],cnt=<span class="number">0</span>;</span><br><span class="line">ll mx=<span class="number">-0x3f3f3f3f</span>,tot=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="keyword">int</span> nex,to; &#125;edge[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].nex=head[u];</span><br><span class="line">    edge[cnt].to=v;</span><br><span class="line">    head[u]=cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=val[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];~i;i=edge[i].nex)</span><br><span class="line">        <span class="keyword">if</span>(edge[i].to!=pre) ans+=max(dfs(edge[i].to,u),<span class="number">0l</span>l);</span><br><span class="line">    mx=max(ans,mx);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=val[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];~i;i=edge[i].nex)</span><br><span class="line">        <span class="keyword">if</span>(edge[i].to!=pre) ans+=max(dfs2(edge[i].to,u),<span class="number">0l</span>l);</span><br><span class="line">    <span class="keyword">if</span>(mx==ans) &#123;</span><br><span class="line">        tot++;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,u,v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;val[i]);</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0xff</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">        add(u,v);</span><br><span class="line">        add(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>,mx*tot,tot);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="F-Ehab-and-a-weird-weight-formula"><a href="#F-Ehab-and-a-weird-weight-formula" class="headerlink" title="F. Ehab and a weird weight formula"></a>F. Ehab and a weird weight formula</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给定一个$n$个节点的树，每个节点有点权$a_u$，该树满足条件：对于树上的每个点（除权值最小的点），必有相邻的点$v$，使$a_v&lt;a_u$。要求构建一棵树，使树的权重最小。生成树的权重计算如下：</p><ul><li>对于每个点$u$,$w+=deg_u \cdot a_u$($deg_u$为生成树中节点$u$的度)</li><li>对于树上每条边${u,v}$,$w+=\lceil log_2(dist(u,v)) \rceil \cdot min(a_u,a_v)$，$dist(u,v)$为生成树上点$u,v$间的距离</li></ul><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>对于所给的树，有如下性质：对于节点$u$的所有子节点$v$，有$a_v&gt;a_u$.即随着深度的增加，节点点权增加。</p><p>那么对于节点$u$，向上求第$1-2^k$倍的祖先节点$v$，用ST表求$\lceil log_2(dist(u,v)) \rceil \cdot min(a_u,a_v)+a[v]$的最小值，即可求出生成树的总权重。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn],root=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">25</span>][maxn];</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>][u]=pre;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(dp[i<span class="number">-1</span>][u]!=<span class="number">-1</span>) dp[i][u]=dp[i<span class="number">-1</span>][dp[i<span class="number">-1</span>][u]];</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    ll tmp=<span class="number">0xffffffff</span>;</span><br><span class="line">    <span class="keyword">for</span>(d=<span class="number">0</span>;d&lt;<span class="number">20</span>&amp;&amp;dp[d][u]!=<span class="number">-1</span>;d++)</span><br><span class="line">        tmp=min(tmp,<span class="number">1l</span>l*(d+<span class="number">1</span>)*a[dp[d][u]]+a[u]);</span><br><span class="line">    tmp=min(tmp,<span class="number">1l</span>l*(d+<span class="number">1</span>)*a[root]+a[u]);</span><br><span class="line">    <span class="keyword">if</span>(~pre) ans+=tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edge[u].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=edge[u][i];</span><br><span class="line">        <span class="keyword">if</span>(v!=pre) dfs(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,u,v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;a[root]) root=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">        edge[u].push_back(v);</span><br><span class="line">        edge[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0xff</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">    dfs(root,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Codeforces Round </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「2018 ACM-ICPC Nanjing - Onsite」M - Mediocre String Problem (字符串)</title>
      <link href="/2018/11/19/ACM-ICPC-2018-Nanjing-Onsite-M/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://codeforces.com/gym/101981/attachments" target="_blank" rel="noopener">M-Mediocre String Problem</a><br>给定字符串S,T，求S的子串与T的前缀子串能够组成的回文串个数</p></blockquote><a id="more"></a><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定两个字符串$s ,t$，取$s$的子串$s’$和$t$的前缀子串$t’$，并使$|s’|&gt;|t’|$.拼接$s’,t’$得到$str=s’+t’$,求能使$str$为回文串的总方案数。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由于$|s’|&gt;|t’|$，可令$s’=a+b,t’=c ，(|a|=|c|&gt;0,|b|&gt;0)$</p><p>因此$str=a+b+c$，由回文串性质可知，$b$为长度大于0的回文串，且$reverse(a)=c$</p><p>如，对于字符串$s=aabbcdedc,t=bbaa$，以$x=4$为例</p><p>$aabb|cdedc$</p><p>$aabb$</p><p>$\;\;abb$</p><p> $\;\;\;\;bb$</p><p>$\;\;\;\;\;b$</p><p>$a,c$有以上4种取法，$b=c或b=cdedc$，共有2×4=8种情况</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>对于$1≤i≤|s|$求出以$s$以第$i$位开头的回文串个数$CNT(i)$，可以采用Manacher，利用回文串性质差分求解；</p><p>翻转$s$,利用ex-KMP求解$reverse(s)$的后缀与$t$的最长公共前缀$LCP$；</p><p>对于原串$s$的第$x$位，能够组成的回文串个数为$LCP(x)·CNT(x+1)$，求和即为所求解.</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[maxn],t[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> tmp[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> Len[maxn&lt;&lt;<span class="number">1</span>],cnt[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    tmp[<span class="number">0</span>]=<span class="string">'@'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*len;i+=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp[i]=<span class="string">'#'</span>;</span><br><span class="line">        tmp[i+<span class="number">1</span>]=str[i/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    tmp[<span class="number">2</span>*len+<span class="number">1</span>]=<span class="string">'#'</span>;</span><br><span class="line">    tmp[<span class="number">2</span>*len+<span class="number">2</span>]=<span class="string">'$'</span>;</span><br><span class="line">    tmp[<span class="number">2</span>*len+<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*len+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">manacher</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mx=<span class="number">0</span>,ans=<span class="number">0</span>,pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len=init(str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mx&gt;i) Len[i]=min(mx-i,Len[<span class="number">2</span>*pos-i]);</span><br><span class="line">        <span class="keyword">else</span> Len[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(tmp[i-Len[i]]==tmp[i+Len[i]]) Len[i]++;</span><br><span class="line">        <span class="keyword">if</span>(Len[i]+i&gt;mx) mx=Len[i]+i,pos=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp[i]==<span class="string">'#'</span>&amp;&amp;Len[i]==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> x=i/<span class="number">2</span>-Len[i]/<span class="number">2</span>,y=(Len[i]<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>((Len[i]<span class="number">-1</span>)%<span class="number">2</span>==<span class="number">0</span>) y--;</span><br><span class="line">        cnt[x]++;</span><br><span class="line">        cnt[x+y+<span class="number">1</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> extend[maxn],nex[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    nex[<span class="number">0</span>]=len;</span><br><span class="line">    <span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(pos+<span class="number">1</span>&lt;len&amp;&amp;s[pos]==s[pos+<span class="number">1</span>]) pos++;</span><br><span class="line">    nex[<span class="number">1</span>]=pos;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">1</span>,L;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pos=k+nex[k]<span class="number">-1</span>;</span><br><span class="line">        L=nex[i-k];</span><br><span class="line">        <span class="keyword">if</span>(i+L&lt;=pos) nex[i]=L;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> j=pos-i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;<span class="number">0</span>) j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i+j&lt;len&amp;&amp;s[i+j]==s[j]) j++;</span><br><span class="line">            nex[i]=j;</span><br><span class="line">            k=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getExtend</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">char</span> *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lens=<span class="built_in">strlen</span>(s),lent=<span class="built_in">strlen</span>(t);</span><br><span class="line">    getNext(t);</span><br><span class="line">    <span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(pos&lt;lens&amp;&amp;pos&lt;lent&amp;&amp;s[pos]==t[pos]) pos++;</span><br><span class="line">    extend[<span class="number">0</span>]=pos;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>,L;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;lens;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pos=k+extend[k]<span class="number">-1</span>;</span><br><span class="line">        L=nex[i-k];</span><br><span class="line">        <span class="keyword">if</span>(i+L&lt;=pos) extend[i]=L;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> j=pos-i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;<span class="number">0</span>) j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i+j&lt;lens&amp;&amp;j&lt;lent&amp;&amp;s[i+j]==t[j]) j++;</span><br><span class="line">            extend[i]=j;</span><br><span class="line">            k=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,s,t);</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="keyword">int</span> lens=<span class="built_in">strlen</span>(s),lent=<span class="built_in">strlen</span>(t);</span><br><span class="line">    manacher(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lens;i++) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">    reverse(s,s+lens);</span><br><span class="line">    getExtend(s,t);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;lens;i++)</span><br><span class="line">        ans+=<span class="number">1l</span>l*cnt[lens-i]*extend[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> String </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Manacher </tag>
            
            <tag> exKMP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「BZOJ-3732」Network (Kruskal重构树)</title>
      <link href="/2018/11/16/bzoj-3732/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3732" target="_blank" rel="noopener">BZOJ3732-Network</a><br>给定一个无向图，求图中A点到B点的所有路径中，最长边的最小值</p></blockquote><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>可以直接求出最小生成树，答案即为a到b路径上的最小边权，用LCA 求解。</p><p>此处采用Kruskal重构树求解。</p><h4 id="Kruskal重构树"><a href="#Kruskal重构树" class="headerlink" title="Kruskal重构树"></a>Kruskal重构树</h4><p>在Kruskal算法中，当找到两个不属于同一集合的联通块（子树）时，我们直接用边将两联通块相连，从而构建出最小生成树。</p><p>在Kruskal重构树中，对于两个不属于同一集合的联通块，我们首先建立一个虚点，作为两个子树的父节点，让两个子树的根节点与虚点相连，即可构造Kruskal重构树。虚点的点权即为原边的边权。</p><p>通过这一性质，我们成功将最小生成树上的路径信息转化成了点权信息。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>Kruskal重构树的构建过程如下：</p><ol><li><p>将边对于边权从小到大进行排序；</p></li><li><p>遍历边集，用并查集维护两点的连通性，若祖先不相同，则建立一个权值为边权的节点，其左右儿子分别为两个点的祖先节点，并将当前点设为两联通块的根节点；<br><img src="https://images2018.cnblogs.com/blog/1101696/201807/1101696-20180722084252832-1224079802.png" alt="img"></p></li></ol><p>对于构建完成的Kruskal重构树，对u,v求其LCA的点权即为所求解。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> u,v,w;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Edge e) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> w&lt;e.w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;es[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,pre[maxn],val[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x==pre[x]?x:pre[x]=Find(pre[x]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[u].push_back(v);</span><br><span class="line">pre[v]=u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dep[maxn],fa[maxn][<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> pre)</span><span class="comment">//预处理各节点深度+初始fa[u][0]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dep[u]=dep[pre]+<span class="number">1</span>;</span><br><span class="line">fa[u][<span class="number">0</span>]=pre;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tree[u].size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=tree[u][i];</span><br><span class="line"><span class="keyword">if</span>(v!=pre) dfs(v,u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span><span class="comment">//预处理fa数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">1</span>;u&lt;=n;u++)</span><br><span class="line">fa[u][i]=fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************求LCA(u,v)**************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dep[u]&lt;dep[v])</span><br><span class="line">swap(u,v);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d=dep[u]-dep[v];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=d;i++)<span class="comment">//将u上调d个距离</span></span><br><span class="line"><span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&amp;d) u=fa[u][i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(u==v) <span class="keyword">return</span> u;<span class="comment">//特判此时u,v是否在同一位置，如果是，u,v都在LCA上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=(<span class="keyword">int</span>)<span class="built_in">log</span>(n);i&gt;=<span class="number">0</span>;i--)<span class="comment">//同时上调u,v</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(fa[u][i]!=fa[v][i])</span><br><span class="line">&#123;</span><br><span class="line">u=fa[u][i];</span><br><span class="line">v=fa[v][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fa[u][<span class="number">0</span>];<span class="comment">//最后会使u,v成为LCA的子节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m,k,u,v,w;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++) pre[i]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;es[i].u, &amp;es[i].v, &amp;es[i].w);</span><br><span class="line">sort(es,es+m);</span><br><span class="line"><span class="keyword">int</span> index=n,lim=n&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">u=es[i].u,v=es[i].v,w=es[i].w;</span><br><span class="line"><span class="keyword">int</span> fx=Find(u),fy=Find(v);</span><br><span class="line"><span class="keyword">if</span>(fx==fy) <span class="keyword">continue</span>;</span><br><span class="line">index++;</span><br><span class="line">add(index,fx);</span><br><span class="line">add(index,fy);</span><br><span class="line">val[index]=w;</span><br><span class="line"><span class="keyword">if</span>(index==lim<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">dep[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">n=index;</span><br><span class="line">dfs(index,<span class="number">0</span>);</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">while</span>(k--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,val[LCA(u,v)]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCA </tag>
            
            <tag> Kruskal重构树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「ZOJ-3430」Detect the Virus (AC自动机)</title>
      <link href="/2018/11/08/ZOJ-3430/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=4114" target="_blank" rel="noopener">「ZOJ-3430」Detect the Virus</a><br>AC自动机，求每个匹配串能匹配的模式串种类数</p></blockquote><a id="more"></a><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定$n$个模式串和$m$个匹配串(均以<code>base64</code>加密)，求匹配串中出现模式串的种类个数。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>对于<code>base64</code>的解码，即将字符对应的6位二进制串转化为8位二进制数，可以通过位运算完成，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取编码后字符串当前位的二进制串，置于后6位</span></span><br><span class="line">len+=<span class="number">6</span>,x=(x&lt;&lt;<span class="number">6</span>)|base64[encode[i]];</span><br><span class="line"><span class="keyword">if</span>(len&gt;=<span class="number">8</span>) &#123;</span><br><span class="line">    <span class="comment">//取x的前8位，即为解码后的字符</span></span><br><span class="line">decode[p++] = (x &gt;&gt; (len - <span class="number">8</span>)) &amp; <span class="number">0xff</span>;</span><br><span class="line">len -= <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>理论上解码之后就可以当做AC自动机模板题做然而</del></p><ul><li><code>Segmentation Fault</code> ：解码之后的字符串范围在0-256，需要使用<code>unsigned char</code>，否则会导致数组下标小于零越界(其实<code>int</code>也可以）;</li><li><code>Wrong Answer</code>：解码后的字符串值包含0，不能直接使用<code>strlen(str)</code>求解字符串长度；</li><li><code>Wrong Answer</code>：求解的是字符串的<code>种类数</code></li></ul><p>好了我就这么被卡了5小时。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> b64[]=<span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">50000</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> str[<span class="number">5000</span>+<span class="number">10</span>],enstr[<span class="number">5000</span>+<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">decode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">0</span>,x=<span class="number">0</span>,p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;enstr[i]&amp;&amp;enstr[i]!=<span class="string">'='</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        len+=<span class="number">6</span>,x=(x&lt;&lt;<span class="number">6</span>)|mp[enstr[i]];</span><br><span class="line">        <span class="keyword">if</span>(len&gt;=<span class="number">8</span>) &#123;</span><br><span class="line">            str[p++] = (x &gt;&gt; (len - <span class="number">8</span>)) &amp; <span class="number">0xff</span>;</span><br><span class="line">            len -= <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ACAutomation</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> nex[maxn][<span class="number">256</span>],fail[maxn],en[maxn],vis[maxn];</span><br><span class="line">    <span class="keyword">int</span> root,L;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)</span><br><span class="line">            nex[L][i]=<span class="number">-1</span>;</span><br><span class="line">        en[L++]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> L<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        L=<span class="number">0</span>;</span><br><span class="line">        root=newnode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> buf[],<span class="keyword">int</span> len,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nex[now][buf[i]]==<span class="number">-1</span>)</span><br><span class="line">                nex[now][buf[i]]=newnode();</span><br><span class="line">            now=nex[now][buf[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        en[now]=key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        fail[root]=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(nex[root][i]==<span class="number">-1</span>)</span><br><span class="line">                nex[root][i]=root;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                fail[nex[root][i]]=root;</span><br><span class="line">                Q.push(nex[root][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">while</span>(!Q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> now=Q.front();</span><br><span class="line">            Q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)</span><br><span class="line">                <span class="keyword">if</span>(nex[now][i]==<span class="number">-1</span>)</span><br><span class="line">                    nex[now][i]=nex[fail[now]][i];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    fail[nex[now][i]]=nex[fail[now]][i];</span><br><span class="line">                    Q.push(nex[now][i]);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> buf[],<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now=root;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            now=nex[now][buf[i]];</span><br><span class="line">            <span class="keyword">int</span> tmp=now;</span><br><span class="line">            <span class="keyword">while</span>(tmp!=root)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(en[tmp]) vis[en[tmp]]=<span class="literal">true</span>;</span><br><span class="line">                tmp=fail[tmp];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(vis[i]) res++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;AC;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">64</span>;i++) mp[b64[i]]=i;</span><br><span class="line">    <span class="keyword">int</span> m,len;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        AC.init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,enstr);</span><br><span class="line">            len=decode();</span><br><span class="line">            AC.insert(str,len,i);</span><br><span class="line">        &#125;</span><br><span class="line">        AC.build();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,enstr);</span><br><span class="line">            len=decode();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,AC.query(str,len));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> String </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC自动机 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「LA-3942」Remember the Word (Trie树+DP)</title>
      <link href="/2018/10/27/UVALive-3942/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1943" target="_blank" rel="noopener">「LA-3942」Remember the Word</a><br>Trie+DP，求解若干个模式串组合构成目标串的方案数</p></blockquote><a id="more"></a><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个由小写字母组成的长字符串$S(1≤|S|≤300000)$和$N(1≤N≤4000)$条短字符串$C_i(1≤|C_i|≤100)$，求用短字符串构成长字符串的方案数，结果对$20071027$取模。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>对于目标串$S$，构建数组$dp[i]$，表示位于$i$时，字符串的后缀$S’$的组成方案数。</p><p>对于模式串$C_i$，若其能与$S’$长度为$len$的前缀子串匹配，则有状态转移方程$dp[i]+=dp[i+len+1]$，由于$|C_i|≤100$，则最多只需枚举长度为$100$的前缀子串。</p><p>考虑对模式串$C_i$建立Trie树，枚举后缀子串$S’$即可求解。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">20071027</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn],len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> trie[maxn][<span class="number">30</span>],tot;</span><br><span class="line"><span class="keyword">bool</span> val[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_ch</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">int</span> root=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> id=str[i]-<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[root][id]) trie[root][id]=++tot;</span><br><span class="line">root=trie[root][id];</span><br><span class="line">&#125;</span><br><span class="line">val[root]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_ch</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> root=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=pos;i&lt;len&amp;&amp;i&lt;=pos+<span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> id=str[i]-<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[root][id]) <span class="keyword">return</span>;</span><br><span class="line">root=trie[root][id];</span><br><span class="line"><span class="keyword">if</span>(val[root]) (dp[pos]+=dp[i+<span class="number">1</span>])%=mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(trie,<span class="number">0</span>,<span class="keyword">sizeof</span> trie);</span><br><span class="line"><span class="built_in">memset</span>(val,<span class="number">0</span>,<span class="keyword">sizeof</span> val);</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">tot=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> t[<span class="number">105</span>];</span><br><span class="line">    <span class="keyword">int</span> n,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,t);</span><br><span class="line">            insert_ch(t);</span><br><span class="line">        &#125;</span><br><span class="line">        len=<span class="built_in">strlen</span>(s);</span><br><span class="line">        dp[len]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) find_ch(s,i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>,++cnt,dp[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> String </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> Trie树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Codeforces Round 513 (rated, Div. 1 + Div. 2)</title>
      <link href="/2018/10/07/Codeforces%20Round%20513/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://codeforces.com/contest/1060" target="_blank" rel="noopener">Codeforces Round #513 by Barcelona Bootcamp (rated, Div. 1 + Div. 2)</a></p></blockquote><p>渡劫失败，菜得安详，自闭了。<br><a id="more"></a></p><h1 id="A-Phone-Numbers"><a href="#A-Phone-Numbers" class="headerlink" title="A.Phone Numbers"></a>A.Phone Numbers</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一组数字，计算在每一组数字串均以<code>8</code>开头的前提下，能构成的长度为11的字符串的最大数量。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">105</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">'8'</span>) cnt++;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=n-i;</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;=i*<span class="number">10</span>) ans=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-Maximum-Sum-of-Digits"><a href="#B-Maximum-Sum-of-Digits" class="headerlink" title="B.Maximum Sum of Digits"></a>B.Maximum Sum of Digits</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>$S(x)$表示数字$x$各位相加的值。给定一个数$x$，令$a+b=x$，求$S(a)+S(b)$的最大值。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>贪心。使a中包含尽可能多的9，即为所求解。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">10</span>) <span class="keyword">return</span> <span class="number">0</span>*<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,n);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmp=<span class="number">1</span>,i=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(tmp&lt;=n) tmp*=<span class="number">10</span>,i++;</span><br><span class="line">    tmp/=<span class="number">10</span>;</span><br><span class="line">    tmp--;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    ans=i*<span class="number">9</span>;</span><br><span class="line">    tmp=n-tmp;</span><br><span class="line">    <span class="keyword">while</span>(tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=tmp%<span class="number">10</span>;</span><br><span class="line">        tmp/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-Maximum-Subrectangle"><a href="#C-Maximum-Subrectangle" class="headerlink" title="C.Maximum Subrectangle"></a>C.Maximum Subrectangle</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给定数组$a,b$,建立矩阵$c$，令矩阵$c[i][j]=a[i]·b[j]$，求不超过$x$的最大子矩阵和。</p><h2 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h2><p>可以得知子矩阵和为$(a[i]+a[i+1]+…+a[j])*(b[i]+b[i+1]+…+b[j])$.</p><p>对数组$a,b$求前缀和，分别计算出$a,b$区间长度为$[1,n]$时所能达到的最大值，遍历求解即可。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x,a[<span class="number">2005</span>],b[<span class="number">2005</span>],ma[<span class="number">2005</span>],mb[<span class="number">2005</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    a[<span class="number">0</span>]=b[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">        a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;b[i]);</span><br><span class="line">        b[i]+=b[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;x);</span><br><span class="line">    <span class="built_in">memset</span>(ma,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> ma);</span><br><span class="line">    <span class="built_in">memset</span>(mb,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> mb);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">            ma[j-i+<span class="number">1</span>]=min(ma[j-i+<span class="number">1</span>],a[j]-a[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=m;j++)</span><br><span class="line">            mb[j-i+<span class="number">1</span>]=min(mb[j-i+<span class="number">1</span>],b[j]-b[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="keyword">if</span>(ma[i]*mb[j]&lt;=x) ans=max(ans,i*j);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-Social-Circles"><a href="#D-Social-Circles" class="headerlink" title="D.Social Circles"></a>D.Social Circles</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>使用若干个圆桌，给$n$个人排座位。每个人左边需要有$L[i]$个空凳子，右边需要有$R[i]$个空凳子，求最少需要的凳子数。</p><h2 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h2><p>贪心。</p><p>每次加入一个人，这个人可能与他人相邻或与自己成环。与他人相连时，所需的值为$max(L_{i},R_{j})+1$；与自己成环时，所需的值为$max(L_i,R_i)+1$.要使总贡献最小，只需要使当前所取得的$max(L,R)$最小。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> l[maxn],r[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l[i],&amp;r[i]);</span><br><span class="line">    sort(l,l+n);</span><br><span class="line">    sort(r,r+n);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        ans+=max(l[i],r[i])+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Codeforces Round </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「CodeForces-498C」Array and Operations(数论+网络流)</title>
      <link href="/2018/10/03/CodeForces-498C/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://codeforces.com/problemset/problem/498/C" target="_blank" rel="noopener">「CodeForces-498C」Array and Operations</a><br>给定n个点和m个边集，每次操作可以将相连边的两个点值同时除以一个公约数，问最大操作次数</p></blockquote><a id="more"></a><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个长为$n$的数组，以及$m$对下标为$(a,b)$的点对，且满足下标a+b为奇数（即奇数点只与偶数点匹配），每次操作可以将同一组的两个数同时除以一个公约数，问最多能进行多少次操作。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>显然题目所给的是一个二分图。</p><p>对于每个质因数分开考虑。对于奇数点，向源点连接一个容量为该因子个数的边；对于偶数点，则向汇点建立一个容量为因子数的边；对于有边相连的点对，建立容量为$inf$的边。</p><p>对于题给的数组$a[i]$，通过分解质因数的方式计算每个质因数所建图的最大流，求和即为所求解。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_V=<span class="number">200</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于表示边的结构体（终点，流量，反向边）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> to,cap,rev;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; G[MAX_V];<span class="comment">//图的邻接表表示</span></span><br><span class="line"><span class="keyword">int</span> level[MAX_V];<span class="comment">//顶点到源点的距离标号</span></span><br><span class="line"><span class="keyword">int</span> iter[MAX_V];<span class="comment">//当前弧</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">G[from].push_back((edge)&#123;to,cap,G[to].size()&#125;);</span><br><span class="line">G[to].push_back((edge)&#123;from,<span class="number">0</span>,G[from].size()<span class="number">-1</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算从源点出发的距离标号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(level,<span class="number">-1</span>,<span class="keyword">sizeof</span>(level));</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">level[s]=<span class="number">0</span>;</span><br><span class="line">que.push(s);</span><br><span class="line"><span class="keyword">while</span>(!que.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=que.front();que.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[v].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">edge &amp;e=G[v][i];</span><br><span class="line"><span class="keyword">if</span>(e.cap&gt;<span class="number">0</span>&amp;&amp;level[e.to]&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">level[e.to]=level[v]+<span class="number">1</span>;</span><br><span class="line">que.push(e.to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过DFS寻找增广路</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> t,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(v==t) <span class="keyword">return</span> f;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> &amp;i=iter[v];i&lt;G[v].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">edge &amp;e=G[v][i];</span><br><span class="line"><span class="keyword">if</span>(e.cap&gt;<span class="number">0</span> &amp;&amp; level[v]&lt;level[e.to])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> d=dfs(e.to,t,min(f,e.cap));</span><br><span class="line"><span class="keyword">if</span>(d&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">e.cap-=d;</span><br><span class="line">G[e.to][e.rev].cap+=d;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求解从s到t的最大流</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_flow</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> flow=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line">bfs(s);</span><br><span class="line"><span class="keyword">if</span>(level[t]&lt;<span class="number">0</span>) <span class="keyword">return</span> flow;</span><br><span class="line"><span class="built_in">memset</span>(iter,<span class="number">0</span>,<span class="keyword">sizeof</span>(iter));</span><br><span class="line"><span class="keyword">int</span> f;</span><br><span class="line"><span class="keyword">while</span>((f=dfs(s,t,INF))&gt;<span class="number">0</span>) flow+=f;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,a[<span class="number">105</span>],u[<span class="number">105</span>],v[<span class="number">105</span>],s,t,ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAX_V;i++) G[i].clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(a[i]%x==<span class="number">0</span>) a[i]/=x,tot++;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span>) add(s,i,tot);</span><br><span class="line">        <span class="keyword">else</span> add(i,t,tot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) add(u[i],v[i],INF);</span><br><span class="line">    ans+=max_flow(s,t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u[i],&amp;v[i]);</span><br><span class="line">        <span class="keyword">if</span>(v[i]&amp;<span class="number">1</span>) swap(u[i],v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    s=<span class="number">0</span>,t=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j*j&lt;=a[i];j++)</span><br><span class="line">            <span class="keyword">if</span>(a[i]%j==<span class="number">0</span>) solve(j);</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;<span class="number">1</span>) solve(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Graph </category>
          
          <category> Network Flow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「SPOJ-P104」Highways(生成树计数)</title>
      <link href="/2018/10/02/SPOJ-P104/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="https://www.spoj.com/problems/HIGH/" target="_blank" rel="noopener">「SPOJ-P104」Highways</a><br>Matrix-Tree定理，求生成树的个数</p></blockquote><a id="more"></a><hr><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>一个有n座城市的组成国家，城市1至n编号，其中一些城市之间可以修建高速公路，需要有选择的修建一些高速公路，从而组成一个交通网络。计算有多少种方案，使得任意两座城市之间恰好只有一条路径。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>1、图G的度数矩阵$D[G]$，满足当$i≠j$ 时,$d_{ij}=0$；当$i=j$时，$d_{ij}$ 等于$vi$ 的度数。</p><p>2、图G的邻接矩阵$A[G]$</p><p>定义图G的基尔霍夫矩阵$C[G]=D[G]-A[G]$有如下性质：</p><p>①对于任意一个图,他的基尔霍夫矩阵C的行列式的值为0. </p><p>②如果图G不连通,其基尔霍夫矩阵的任意主子式行列式值为0.</p><p>③若图G是一棵树,则C[G]的任意一个n-1阶主子式的行列式的值为1. </p><h4 id="Matrix-Tree定理"><a href="#Matrix-Tree定理" class="headerlink" title="Matrix-Tree定理"></a>Matrix-Tree定理</h4><p>定义$G $的所有不同的生成树的个数等于其Kirchhoff矩阵$C[G]$任何一个$n-1 $阶主子式的行列式的绝对值。所谓$n-1$ 阶主子式，就是对于$r(1≤r≤n)$，将$C[G]$的第$r$ 行、第$r $列同时去掉后得到的新矩阵，用$Cr[G]$表示。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><blockquote><p><a href="https://en.wikipedia.org/wiki/Kirchhoff%27s_theorem" target="_blank" rel="noopener">Kirchhoff’s theorem</a><br><a href="https://wenku.baidu.com/view/872eb02de2bd960590c677c6.html" target="_blank" rel="noopener">2007年国家集训队论文  周冬《生成树的计数及其应用》</a></p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> C[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">det</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">while</span>(C[j][i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> t=C[i][i]/C[j][i];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=n;k++)</span><br><span class="line">                    C[i][k]=(C[i][k]-C[j][k]*t);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=n;k++)</span><br><span class="line">                    swap(C[i][k],C[j][k]);</span><br><span class="line">                ret=-ret;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(!C[i][i])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ret=ret*C[i][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret&gt;<span class="number">0</span>?ret:-ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,n,m,u,v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="built_in">memset</span>(C,<span class="number">0</span>,<span class="keyword">sizeof</span> C);</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">            C[u][u]++;C[v][v]++;</span><br><span class="line">            C[u][v]--;C[v][u]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,det(n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matrix-Tree定理 </tag>
            
            <tag> 基尔霍夫矩阵 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「HDU-4821」String(字符串hash)</title>
      <link href="/2018/09/27/HDU-4821/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4821" target="_blank" rel="noopener">「HDU-4821」String</a><br>字符串hash，求长度为m*l子串中m个小子串两两互不完全相同的子串个数</p></blockquote><a id="more"></a><p>*假的字符串选手发现自己甚至不会hash，学习一个。</p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个字符串，求将长度为m*l的子串分割为每段长度为l的m段后，m段两两互不完全相同的子串个数。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对字符串求hash值，map计数去重，判断当前不同字符串数是否等于m.</p><p>对于每个中间区间相同的区间，利用滑动窗口求解降低复杂度，即：删除左侧子串哈希值，将右边区间哈希值加入集合。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> seed=<span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">ull base[maxn],h[maxn];</span><br><span class="line"><span class="built_in">map</span> &lt;ull,<span class="keyword">int</span>&gt; hashmap;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">gethash</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;<span class="keyword">return</span> h[r]-h[l<span class="number">-1</span>]*base[r-l+<span class="number">1</span>]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,l,len;</span><br><span class="line">    base[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;maxn;i++)</span><br><span class="line">        base[i]=base[i<span class="number">-1</span>]*seed;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;l)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line">        len=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">            h[i]=h[i<span class="number">-1</span>]*seed+s[i]-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=l&amp;&amp;i+m*l&lt;=len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            hashmap.clear();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+m*l;j+=l)</span><br><span class="line">                hashmap[gethash(j,j+l<span class="number">-1</span>)]++;</span><br><span class="line">            <span class="keyword">if</span>(hashmap.size()==m) cnt++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=len-m*l-l+<span class="number">1</span>;j+=l)</span><br><span class="line">            &#123;</span><br><span class="line">                ull tmp=gethash(j,j+l<span class="number">-1</span>);</span><br><span class="line">                hashmap[tmp]--;</span><br><span class="line">                <span class="keyword">if</span>(!hashmap[tmp]) hashmap.erase(tmp);</span><br><span class="line">                hashmap[gethash(j+m*l,j+m*l+l<span class="number">-1</span>)]++;</span><br><span class="line">                <span class="keyword">if</span>(hashmap.size()==m) cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> String </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hash </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「2018 ACM-ICPC Xuzhou - Online」J - Maze Designer(最大生成树+LCA)</title>
      <link href="/2018/09/25/ACM-ICPC-2018-Xuzhou-Online-J/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="https://nanti.jisuanke.com/t/31462" target="_blank" rel="noopener">J-Maze Designer</a><br>建立最大生成树，求树上任意两点之间的距离</p></blockquote><a id="more"></a><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个$n×m$的网格，在两个相邻点之间建立一堵墙会有一定的花费。建立一个迷宫，使任意两点之间只有一条路径可达，求在最低建造成本下，给定任意两点之间的路径。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>考虑在所有墙都建立的情况下，移除若干堵墙，使所有点连通，让所有点连通的最大花费即为题目所求的建造方案。建立最大生成树后求两点间的LCA，即可求解。</p><p>*我也不知道我比赛时候写的离线LCA有啥问题</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">250000</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cost;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> edge &amp;e) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cost&gt;e.cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;es[<span class="number">2</span>*maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre[maxn],cnt,E,V;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> pre[x]==x?x:pre[x]=Find(pre[x]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=V;i++) pre[i]=i;</span><br><span class="line">    sort(es,es+E);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;E;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        edge e=es[i];</span><br><span class="line">        <span class="keyword">int</span> fx=Find(e.u),fy=Find(e.v);</span><br><span class="line">        <span class="keyword">if</span>(fx!=fy)</span><br><span class="line">        &#123;</span><br><span class="line">            pre[fx]=fy;</span><br><span class="line">            tree[e.v].push_back(e.u);</span><br><span class="line">            tree[e.u].push_back(e.v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dep[maxn],fa[maxn+<span class="number">1</span>][<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************预处理过程**************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> pre)</span><span class="comment">//预处理各节点深度+初始fa[u][0]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dep[u]=dep[pre]+<span class="number">1</span>;</span><br><span class="line">fa[u][<span class="number">0</span>]=pre;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tree[u].size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=tree[u][i];</span><br><span class="line"><span class="keyword">if</span>(v!=pre) dfs(v,u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span><span class="comment">//预处理fa数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=V;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">1</span>;u&lt;=V;u++)</span><br><span class="line">fa[u][i]=fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************求LCA(u,v)**************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&lt;dep[v])</span><br><span class="line">swap(u,v);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d=dep[u]-dep[v];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=d;i++)<span class="comment">//将u上调d个距离</span></span><br><span class="line"><span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&amp;d) u=fa[u][i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(u==v) <span class="keyword">return</span> u;<span class="comment">//特判此时u,v是否在同一位置，如果是，u,v都在LCA上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=(<span class="keyword">int</span>)<span class="built_in">log</span>(V);i&gt;=<span class="number">0</span>;i--)<span class="comment">//同时上调u,v</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(fa[u][i]!=fa[v][i])</span><br><span class="line">&#123;</span><br><span class="line">u=fa[u][i];</span><br><span class="line">v=fa[v][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fa[u][<span class="number">0</span>];<span class="comment">//最后会使u,v成为LCA的子节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,q,x1,x2,y1,y2,u,v;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> w1,w2;</span><br><span class="line">    <span class="keyword">char</span> s1[<span class="number">5</span>],s2[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    V=n*m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s%lld%s%lld"</span>,s1,&amp;w1,s2,&amp;w2);</span><br><span class="line">            <span class="keyword">if</span>(s1[<span class="number">0</span>]==<span class="string">'D'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                es[cnt].u=(i<span class="number">-1</span>)*n+j;</span><br><span class="line">                es[cnt].v=i*n+j;</span><br><span class="line">                es[cnt++].cost=w1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s1[<span class="number">0</span>]==<span class="string">'R'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                es[cnt].u=(i<span class="number">-1</span>)*n+j;</span><br><span class="line">                es[cnt].v=(i<span class="number">-1</span>)*n+j+<span class="number">1</span>;</span><br><span class="line">                es[cnt++].cost=w1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s2[<span class="number">0</span>]==<span class="string">'D'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                es[cnt].u=(i<span class="number">-1</span>)*n+j;</span><br><span class="line">                es[cnt].v=i*n+j;</span><br><span class="line">                es[cnt++].cost=w2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s2[<span class="number">0</span>]==<span class="string">'R'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                es[cnt].u=(i<span class="number">-1</span>)*n+j;</span><br><span class="line">                es[cnt].v=(i<span class="number">-1</span>)*n+j+<span class="number">1</span>;</span><br><span class="line">                es[cnt++].cost=w2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    E=cnt;</span><br><span class="line">    kruskal();</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">        u=(x1<span class="number">-1</span>)*n+y1;</span><br><span class="line">        v=(x2<span class="number">-1</span>)*n+y2;</span><br><span class="line">        <span class="keyword">int</span> root=LCA(u,v);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="number">-2</span>*dep[root]+dep[u]+dep[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「POJ-2778」DNA Sequence (AC自动机+矩阵快速幂)</title>
      <link href="/2018/09/24/POJ-2778/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://poj.org/problem?id=2778" target="_blank" rel="noopener">「POJ-2778」DNA Sequence</a><br>AC自动机+矩阵快速幂，求长度为n且不包含任一不合法子序列的序列数量</p></blockquote><a id="more"></a><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定m个不合法序列，求所有长度为n，且不包含任何不合法子序列的序列数量(序列中只含A,T,C,G四个字符)。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于给定的m个序列，构建trie树。对于trie树上每一点的单步可达关系建立邻接矩阵，对矩阵求其n次幂，$\sum_{i=1}^n{matrix[0][i]}$即为所求解。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> row,column;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> data[maxn][maxn];</span><br><span class="line">    <span class="function">Matrix <span class="title">mul</span><span class="params">(Matrix a,Matrix b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Matrix ans;</span><br><span class="line">        ans.row=ans.column=a.row;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.row;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>,k;j&lt;b.column;j++)</span><br><span class="line">                <span class="keyword">for</span>(ans.data[i][j]=k=<span class="number">0</span>;k&lt;a.row;k++)</span><br><span class="line">                    (ans.data[i][j]+=a.data[i][k]*b.data[k][j])%=mod;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Matrix <span class="title">pow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Matrix ans,base=*<span class="keyword">this</span>;</span><br><span class="line">        ans.row=ans.column=row;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)</span><br><span class="line">            ans.data[i][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">2</span>)</span><br><span class="line">                ans=mul(ans,base);</span><br><span class="line">            base=mul(base,base);</span><br><span class="line">            n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;matrix;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="string">'A'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="string">'C'</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="string">'T'</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="string">'G'</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ACAutomation</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> trie[maxn][<span class="number">4</span>],fail[maxn];</span><br><span class="line"><span class="keyword">int</span> tag[maxn];</span><br><span class="line"><span class="keyword">int</span> root,L;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">trie[L][i]=<span class="number">-1</span>;</span><br><span class="line">L++;</span><br><span class="line"><span class="keyword">return</span> L<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">L=<span class="number">0</span>;</span><br><span class="line">root=newnode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入模式串，构造单词树(Keyword tree)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> buf[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len=<span class="built_in">strlen</span>(buf);</span><br><span class="line"><span class="keyword">int</span> now=root;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(trie[now][id(buf[i])]==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">trie[now][id(buf[i])]=newnode();</span><br><span class="line">tag[L<span class="number">-1</span>]=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">now=trie[now][id(buf[i])];</span><br><span class="line">&#125;</span><br><span class="line">tag[now]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用BFS计算每个节点的fail指针，构造trie树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">fail[root]=root;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line"><span class="keyword">if</span>(trie[root][i]==<span class="number">-1</span>)</span><br><span class="line">trie[root][i]=root;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">fail[trie[root][i]]=root;</span><br><span class="line">Q.push(trie[root][i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!Q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> now=Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line"><span class="keyword">if</span>(tag[fail[now]]) tag[now]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line"><span class="keyword">if</span>(trie[now][i]==<span class="number">-1</span>)</span><br><span class="line">trie[now][i]=trie[fail[now]][i];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">fail[trie[now][i]]=trie[fail[now]][i];</span><br><span class="line">Q.push(trie[now][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildMatrix</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    matrix.row=matrix.column=L;</span><br><span class="line">    <span class="built_in">memset</span>(matrix.data,<span class="number">0</span>,<span class="keyword">sizeof</span> matrix.data);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;L;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">                <span class="keyword">if</span>(!tag[i]&amp;&amp;!tag[trie[i][j]])</span><br><span class="line">                    matrix.data[i][trie[i][j]]++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;AC;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n);</span><br><span class="line">    AC.init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">        AC.insert(s);</span><br><span class="line">    &#125;</span><br><span class="line">    AC.build();</span><br><span class="line">    AC.buildMatrix();</span><br><span class="line">    matrix=matrix.<span class="built_in">pow</span>(n);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;AC.L;i++)</span><br><span class="line">        (ans+=matrix.data[<span class="number">0</span>][i])%=mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> String </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC自动机 </tag>
            
            <tag> 矩阵快速幂 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「POJ-2449」Remmarguts&#39; Date(k短路)</title>
      <link href="/2018/09/10/POJ-2449/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://poj.org/problem?id=2449" target="_blank" rel="noopener">「POJ2499」Remmarguts’ Date</a><br>A*算法，k短路问题</p></blockquote><a id="more"></a><hr><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一张有向图，求s到t的第k短路。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><h4 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h4><p><a href="https://zh.wikipedia.org/wiki/A*%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">A*算法</a>是一种启发式搜索算法。用于在图形平面上，对于有多个节点的路径，求出最低通过成本。</p><p>启发式搜索:在当前搜索节点往下一步节点时，可以通过启发函数来进行选择，选择代价最小的节点作为下一步节点而跳转其上。</p><p>A*算法的估值函数：</p><p>$$f(n)=g(n)+h(n)$$</p><p>其中：</p><p>$g(n)​$是指从初始状态到当前状态n的<strong>实际花费</strong>。</p><p>$h(n)$是指从当前状态n到最终状态的<strong>估计费用</strong>。</p><p>$f(n)$是指初始状态经过目标n到达最终状态的<strong>估计花费</strong>。</p><h4 id="k短路问题"><a href="#k短路问题" class="headerlink" title="k短路问题"></a>k短路问题</h4><p>在k短路问题中，$g(n)$表示当前已经走过的距离，$h(n)$为当前点到终点t的最短路；</p><p>对于估值函数，定义结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> f,g,h;<span class="comment">//f(n),g(n),h(n)函数</span></span><br><span class="line">    <span class="keyword">int</span> id;<span class="comment">//当前点的编号</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> A a)<span class="keyword">const</span>&#123;<span class="comment">//定义比较函数</span></span><br><span class="line">        <span class="keyword">if</span>(a.f==f) <span class="keyword">return</span> a.g&lt;g;</span><br><span class="line">        <span class="keyword">return</span> a.f&lt;f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用优先队列维护$f(n)$，使每次取到的最小的$f(n)$即为当前状态到目标点的最小花费；我们可以据此确定选取的顺序，并保证每一次更新的距离一定是当前所有情况能转移到的最小情况。</p><p>为了确定目标点被走过的次数，我们通常用$cnt$表示终点被经过的次数当$cnt=k$时，终止循环。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">100000</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k,cnt,head[maxn],revhead[maxn],dis[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,w,nex;</span><br><span class="line">&#125;edge[maxm],revedge[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0xff</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="built_in">memset</span>(revhead,<span class="number">0xff</span>,<span class="keyword">sizeof</span> revhead);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].v=v,revedge[cnt].v=u;</span><br><span class="line">    edge[cnt].w=revedge[cnt].w=w;</span><br><span class="line">    edge[cnt].nex=head[u];</span><br><span class="line">    revedge[cnt].nex=revhead[v];</span><br><span class="line">    head[u]=revhead[v]=cnt;</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> src)</span>      <span class="comment">//建立反向图，求图中所有点到终点的最短路径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dis[i]=inf;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    vis[src]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    que.push(src);</span><br><span class="line">    dis[src]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        vis[u]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=revhead[u];~i;i=revedge[i].nex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v=revedge[i].v,w=revedge[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[v]&gt;dis[u]+w)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v]=dis[u]+w;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    que.push(v);</span><br><span class="line">                    vis[v]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> f,g,h;<span class="comment">//f(n),g(n),h(n)函数</span></span><br><span class="line">    <span class="keyword">int</span> id;<span class="comment">//当前点的编号</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> A a)<span class="keyword">const</span>&#123;<span class="comment">//定义比较函数</span></span><br><span class="line">        <span class="keyword">if</span>(a.f==f) <span class="keyword">return</span> a.g&lt;g;</span><br><span class="line">        <span class="keyword">return</span> a.f&lt;f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Astar</span><span class="params">(<span class="keyword">int</span> src,<span class="keyword">int</span> des)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;A&gt; Q;</span><br><span class="line">    <span class="keyword">if</span>(src==des) k++;   <span class="comment">//如果起点即为终点</span></span><br><span class="line">    <span class="keyword">if</span>(dis[src]==inf) <span class="keyword">return</span> <span class="number">-1</span>;      <span class="comment">//如果起点不能到达终点</span></span><br><span class="line">    A st,now,tmp;</span><br><span class="line">    st.id=src,st.g=<span class="number">0</span>,st.f=st.g+dis[src];    <span class="comment">//定义起始节点</span></span><br><span class="line">    Q.push(st);</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        now=Q.top();Q.pop();</span><br><span class="line">        <span class="keyword">if</span>(now.id==des)     <span class="comment">//如果当前节点为终点</span></span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(cnt==k) <span class="keyword">return</span> now.g;    <span class="comment">//找到第k短路</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[now.id];~i;i=edge[i].nex)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp.id=edge[i].v;</span><br><span class="line">            tmp.g=now.g+edge[i].w;     <span class="comment">//到该点的实际花费</span></span><br><span class="line">            tmp.f=tmp.g+dis[tmp.id];   <span class="comment">//到最终状态的估计花费</span></span><br><span class="line">            Q.push(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//路径总数小于k</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,s,t,u,v,w;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            add(u,v,w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;s,&amp;t,&amp;k);</span><br><span class="line">        spfa(t);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Astar(s,t));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> A*算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「2018 ACM-ICPC Shenyang - Online」F - Fantastic Graph (网络流)</title>
      <link href="/2018/09/08/ACM-ICPC-2018-Shenyang-Online-F/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="https://nanti.jisuanke.com/t/31447" target="_blank" rel="noopener">F-Fantastic Graph</a><br>网络流建模，无源汇有上下界可行流问题</p></blockquote><a id="more"></a><hr><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个二分图和一系列匹配边，求解是否存在匹配边的选择组合，使二分图中的每个点度数$d$满足$l≤d≤r$。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于原二分图建立网络流模型。添加源汇点$s,t$,将其视为有上下界可行流问题求解。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>对于二分图中的每一条边，在网络流中边的流量为上界-下界。为了保证流量平衡，对于每一个出度为$d_i$的 左侧结点$X_i$,从源点建立一条容量为$d_i$的边；同样的，对于每一个出度为$d_i$的右侧结点$Y_i$,建立一条从$Y_i$到汇点的容量为$d_i$的边。建模完成后，从$s$到$t$跑一次最大流即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k,high,low;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_V=<span class="number">6000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> g[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于表示边的结构体（终点，流量，反向边）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> to,cap,rev;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; G[MAX_V];<span class="comment">//图的邻接表表示</span></span><br><span class="line"><span class="keyword">int</span> level[MAX_V];<span class="comment">//顶点到源点的距离标号</span></span><br><span class="line"><span class="keyword">int</span> iter[MAX_V];<span class="comment">//当前弧</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">G[from].push_back((edge)&#123;to,cap,G[to].size()&#125;);</span><br><span class="line">G[to].push_back((edge)&#123;from,<span class="number">0</span>,G[from].size()<span class="number">-1</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算从源点出发的距离标号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(level,<span class="number">-1</span>,<span class="keyword">sizeof</span>(level));</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">level[s]=<span class="number">0</span>;</span><br><span class="line">que.push(s);</span><br><span class="line"><span class="keyword">while</span>(!que.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=que.front();que.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[v].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">edge &amp;e=G[v][i];</span><br><span class="line"><span class="keyword">if</span>(e.cap&gt;<span class="number">0</span>&amp;&amp;level[e.to]&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">level[e.to]=level[v]+<span class="number">1</span>;</span><br><span class="line">que.push(e.to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过DFS寻找增广路</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> t,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(v==t) <span class="keyword">return</span> f;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> &amp;i=iter[v];i&lt;G[v].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">edge &amp;e=G[v][i];</span><br><span class="line"><span class="keyword">if</span>(e.cap&gt;<span class="number">0</span> &amp;&amp; level[v]&lt;level[e.to])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> d=dfs(e.to,t,min(f,e.cap));</span><br><span class="line"><span class="keyword">if</span>(d&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">e.cap-=d;</span><br><span class="line">G[e.to][e.rev].cap+=d;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求解从s到t的最大流</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_flow</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> flow=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line">bfs(s);</span><br><span class="line"><span class="keyword">if</span>(level[t]&lt;<span class="number">0</span>) <span class="keyword">return</span> flow;</span><br><span class="line"><span class="built_in">memset</span>(iter,<span class="number">0</span>,<span class="keyword">sizeof</span>(iter));</span><br><span class="line"><span class="keyword">int</span> f;</span><br><span class="line"><span class="keyword">while</span>((f=dfs(s,t,INF))&gt;<span class="number">0</span>) flow+=f;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v,deu[maxn],dev[maxn],cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAX_V;i++) G[i].clear();</span><br><span class="line">        <span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">        <span class="built_in">memset</span>(deu,<span class="number">0</span>,<span class="keyword">sizeof</span> deu);</span><br><span class="line">        <span class="built_in">memset</span>(dev,<span class="number">0</span>,<span class="keyword">sizeof</span> dev);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;low,&amp;high);</span><br><span class="line">        <span class="built_in">memset</span>(G,<span class="number">0</span>,<span class="keyword">sizeof</span> G);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">            g[u][v]++;</span><br><span class="line">            deu[u]++;</span><br><span class="line">            dev[v]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(deu[i]&lt;low) flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="keyword">if</span>(dev[i]&lt;low) flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//如果某点最大可达到的流量小于low，输出no</span></span><br><span class="line">        <span class="keyword">if</span>(!flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Case %d: %s\n"</span>,++cnt,flag?<span class="string">"Yes"</span>:<span class="string">"No"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> s=n+m+<span class="number">1</span>,e=s+<span class="number">1</span>,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!g[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">                add(i,j,high-low);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) add(s,i,deu[i]),sum+=deu[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) add(i,e,dev[i]);</span><br><span class="line">        <span class="keyword">int</span> ans=max_flow(s,e);</span><br><span class="line">        <span class="keyword">if</span>(ans!=sum) flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %s\n"</span>,++cnt,flag?<span class="string">"Yes"</span>:<span class="string">"No"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Graph </category>
          
          <category> Network Flow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「POJ-2289」Jamie&#39;s Contact Groups (二分图多重匹配+二分)</title>
      <link href="/2018/08/30/POJ-2289/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://poj.org/problem?id=2289" target="_blank" rel="noopener">「POJ-2289」amie’s Contact Groups</a><br>二分图最大多重匹配，求最大分组的最小值</p></blockquote><a id="more"></a><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一系列联系人和其可分到的组，对联系人分组，在所有联系人都有分组的情况下，使最大分组的值最小。求最大分组的最小值。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>匈牙利算法，求解可容纳量$limit$内的二分图多重匹配。二分答案，求出最小的满足左侧点全部匹配的$limit$值即为所求解。也可用网络流求解。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000</span>+<span class="number">5</span>;<span class="comment">//左边最大点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">500</span>+<span class="number">5</span>;<span class="comment">//右边最大点数</span></span><br><span class="line"><span class="keyword">int</span> graph[maxn][maxm],vis[maxm];<span class="comment">//图G和增广路访问标记</span></span><br><span class="line"><span class="keyword">int</span> match[maxm][maxn];<span class="comment">//左边元素与右边元素第n次匹配</span></span><br><span class="line"><span class="keyword">int</span> nx,ny,m;<span class="comment">//左边点数，右边点数,边数</span></span><br><span class="line"><span class="keyword">int</span> limit;</span><br><span class="line"><span class="keyword">int</span> cnt[maxm];<span class="comment">//右边点已匹配值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find_path</span><span class="params">(<span class="keyword">int</span> u)</span><span class="comment">//找增广路</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ny; i++)<span class="comment">//注意，这里节点是从0开始编号，题目有时是从1开始编号</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(graph[u][i] &amp;&amp; !vis[i])<span class="comment">//不在增广路</span></span><br><span class="line">        &#123;</span><br><span class="line">            vis[i]=<span class="number">1</span>;<span class="comment">//放进增广路</span></span><br><span class="line">            <span class="keyword">if</span>(cnt[i]&lt;limit)<span class="comment">//如果当前已匹配数量小于可容纳量，则直接匹配</span></span><br><span class="line">            &#123;</span><br><span class="line">                match[i][cnt[i]++]=u;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;cnt[i]; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(find_path(match[i][j]))<span class="comment">//如果先前已匹配右边的点能另外找到增广路，则此点仍可匹配</span></span><br><span class="line">                &#123;</span><br><span class="line">                    match[i][j]=u;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_match</span><span class="params">()</span><span class="comment">//计算多重匹配的最大匹配数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(match,<span class="number">-1</span>,<span class="keyword">sizeof</span>(match));</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nx; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">if</span>(find_path(i)) res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">all_match</span><span class="params">()</span><span class="comment">//判断左边的点是否都与右边的点匹配了</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nx; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">if</span>(!find_path(i)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">20</span>],c;</span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;nx,&amp;ny)!=EOF&amp;&amp;(nx||ny))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(graph,<span class="number">0</span>,<span class="keyword">sizeof</span> graph);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nx;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">            <span class="keyword">for</span>(;;)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%c"</span>,&amp;u,&amp;c);</span><br><span class="line">                graph[i][u]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(c==<span class="string">'\n'</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">1</span>,r=nx,ans=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">while</span>(r&gt;l)</span><br><span class="line">        &#123;</span><br><span class="line">            limit=(l+r)/<span class="number">2</span>;</span><br><span class="line">            max_match();</span><br><span class="line">            <span class="keyword">if</span>(all_match()) r=limit;</span><br><span class="line">            <span class="keyword">else</span> l=limit+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分图匹配 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「HDU-3488」Tour (有向环覆盖问题)</title>
      <link href="/2018/08/29/HDU-3488/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3488" target="_blank" rel="noopener">「HDU-3488」Tour</a><br>二分图最大权匹配，有向环覆盖问题</p></blockquote><a id="more"></a><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个$n$个顶点、$m$条边的有向图，要求用一个或多个不相交的有向环覆盖所有的节点。问该有向环所有权值的总和最小为多少。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>因为路径由一个或多个不相交的有向环组成，对于匹配之后图中的每一点，其入度=出度=1，即拆点后二分图可以满足完备匹配，二分图中的边即为有向环中的边。</p><p>由于要求的答案为最小权匹配，初始化时需要将边的权值取负数，建立二分图，调用KM算法求其最佳匹配，取反即为所求解。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> lx[maxn],ly[maxn],edge[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> match[maxn],delta;</span><br><span class="line"><span class="keyword">bool</span> vx[maxn],vy[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vx[x]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">1</span>;y&lt;=n;y++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!vy[y])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tmp=lx[x]+ly[y]-edge[x][y];</span><br><span class="line"><span class="keyword">if</span>(!tmp)</span><br><span class="line">&#123;</span><br><span class="line">vy[y]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(!match[y]||dfs(match[y]))</span><br><span class="line">&#123;</span><br><span class="line">match[y]=x;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> delta=min(delta,tmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KM</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">lx[i]=-inf;</span><br><span class="line">ly[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">lx[i]=max(lx[i],edge[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(match,<span class="number">0</span>,<span class="keyword">sizeof</span>(match));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;x++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line">delta=inf;</span><br><span class="line"><span class="built_in">memset</span>(vx,<span class="number">0</span>,<span class="keyword">sizeof</span>(vx));</span><br><span class="line"><span class="built_in">memset</span>(vy,<span class="number">0</span>,<span class="keyword">sizeof</span>(vy));</span><br><span class="line"><span class="keyword">if</span>(dfs(x)) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(vx[i]) lx[i]-=delta;</span><br><span class="line"><span class="keyword">if</span>(vy[i]) ly[i]+=delta;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(match[i]) ans-=edge[match[i]][i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,m,u,v,w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="built_in">memset</span>(edge,-inf,<span class="keyword">sizeof</span> edge);</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            edge[u][v]=max(edge[u][v],-w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,KM());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分图匹配 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「HDU-3829」Cat VS Dog (最大团)</title>
      <link href="/2018/08/28/HDU-3829/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3829" target="_blank" rel="noopener">「HDU3829」Cat VS Dog</a><br>二分图匹配，最大团问题</p></blockquote><a id="more"></a><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>对于p个儿童，每个儿童有其喜欢的动物和讨厌的动物，如果一个儿童喜欢的动物没有被移除，并且讨厌的动物被移除，他/她将会很快乐。求能达到的最大快乐儿童数量。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于每个儿童，如果儿童a喜欢的动物是b讨厌的动物，或者a讨厌的动物是b喜欢的动物，那么a,b存在冲突，即不能同时选择a,b；</p><p>对不存在冲突的a,b连边，那么对于n个儿童，如果他们之间两两相连（即都不存在冲突），则可以同时选择这些儿童。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><blockquote><h4 id="二分图的最大独立集"><a href="#二分图的最大独立集" class="headerlink" title="二分图的最大独立集"></a>二分图的最大独立集</h4><p>定义：选出一些顶点使得这些顶点两两不相邻，则这些点构成的集合称为独立集。找出一个包含顶点数最多的独立集称为最大独立集。<br>方法：最大独立集=所有顶点数-最小顶点覆盖</p><h4 id="二分图的最大团"><a href="#二分图的最大团" class="headerlink" title="二分图的最大团"></a>二分图的最大团</h4><p>定义：对于一个二分图，我们在左边找到一个顶点子集X，在右边找到一个顶点子集Y，使得X中每个顶点和Y中每个顶点之间都有边。<br>方法：二分图的最大团=补图的最大独立集</p></blockquote><p>建立二分图，对不存在冲突的点连边，求解最大团即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">500</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p;</span><br><span class="line"><span class="keyword">int</span> edge[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> linker[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">path</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">1</span>;v&lt;=p;v++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(edge[u][v]&amp;&amp;!vis[v])</span><br><span class="line">        &#123;</span><br><span class="line">            vis[v]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(linker[v]==<span class="number">-1</span>||path(linker[v]))</span><br><span class="line">            &#123;</span><br><span class="line">                linker[v]=u;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hungary</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(linker,<span class="number">0xff</span>,<span class="keyword">sizeof</span>(linker));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=p;i++)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">            res+=path(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">char</span> like[<span class="number">510</span>][<span class="number">20</span>],hate[<span class="number">510</span>][<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;p)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=p;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,like[i],hate[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(edge,<span class="number">1</span>,<span class="keyword">sizeof</span>(edge));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=p;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=p;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">strcmp</span>(like[i],hate[j])!=<span class="number">0</span>&amp;&amp;<span class="built_in">strcmp</span>(like[j],hate[i])!=<span class="number">0</span>) </span><br><span class="line">                    edge[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,(<span class="number">2</span>*p-hungary())/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分图匹配 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「HDU-6446」Tree and Permutation (树形DP)</title>
      <link href="/2018/08/26/HDU-6446/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6446" target="_blank" rel="noopener">「HDU-6446」Tree and Permutation</a><br>推论+树形dp，求解树上所有点对的距离之和</p></blockquote><a id="more"></a><hr><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一棵树，给出树上结点1-n的全排列，求所有排列所经过的路径长度总和。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于树上的某一点对$uv$,在全排列$1-n$中相邻的情况为：</p><p>当$uv$左侧有$m$个点，右侧有$n-2-m$个点时，排列数为(注意$uv$,$vu$为两种情况)</p><p>$$2×{C}{m \choose n-2}×{A}{m \choose m}×{A}{n-2 \choose n-2}=2×(n-2)!$$ </p><p>而这样的排列共有$n-1$种，即对于每一个点对，排列的总数为$2×(n-1)!$种。</p><p>此时只需要求出树上<strong>所有点对的距离之和</strong>即可，可用树形dp求解。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><h4 id="求解树上所有点对的距离之和"><a href="#求解树上所有点对的距离之和" class="headerlink" title="求解树上所有点对的距离之和"></a>求解树上所有点对的距离之和</h4><p>要求解所有点对的距离之和，我们可以求：<strong>对于每条边，所有可能路径经过此条边的次数</strong>。</p><p>设这两条边的两边的点数分别为$s和n-s$,则这条边共经过$s×(n-s)$次,那么当前边对距离总和的贡献为$s×(n-s)×len(u,v)$,对所有边的贡献求和，即为所求解。</p><p>在一棵树中，若需要求其中任意边两端的点数，可以用一次$dfs$求解。取一点为根，记录每个节点的子节点（包含自身）个数，若子节点个数为$a[u]$,父亲一侧节点个数即为$n-a[u]$,时间复杂度为$O(n)$.</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[maxn],cnt,n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> son[maxn],dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nex,to,w;</span><br><span class="line">&#125;edge[<span class="number">20</span>*maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].nex=head[u];</span><br><span class="line">    edge[cnt].to=v;</span><br><span class="line">    edge[cnt].w=w;</span><br><span class="line">    head[u]=cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    son[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];~i;i=edge[i].nex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=edge[i].to,w=edge[i].w;</span><br><span class="line">        <span class="keyword">if</span>(fa==v) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v,u);</span><br><span class="line">        son[u]+=son[v];</span><br><span class="line">        (dp[u]+=(dp[v]+(n-son[v])*son[v]%mod*w%mod)%mod)%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">0xff</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            add(u,v,w);</span><br><span class="line">            add(v,u,w);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++) (res*=i)%=mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(res*dp[<span class="number">1</span>])%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Codeforces Round 506 (Div. 3)</title>
      <link href="/2018/08/25/Codeforces%20Round%20506%20(Div.3)/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://codeforces.com/contest/1029" target="_blank" rel="noopener">Codeforces Round #506 (Div. 3)</a></p></blockquote><a id="more"></a><h3 id="A-Many-Equal-Substrings"><a href="#A-Many-Equal-Substrings" class="headerlink" title="A. Many Equal Substrings"></a>A. Many Equal Substrings</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定一个长度为$n$的字符串$s$，构造一个字符串$t$，使其满足子串$s$出现$k$次，且使$t$长度最短。</p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>调用KMP的next数组求解公共前后缀的长度，输出k次即可。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nex[<span class="number">55</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">char</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">-1</span>;</span><br><span class="line">    nex[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;<span class="built_in">strlen</span>(a))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">-1</span>||a[i]==a[j]) nex[++i]=++j;</span><br><span class="line">        <span class="keyword">else</span> j=nex[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">55</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">    getNext(a);</span><br><span class="line">    <span class="keyword">int</span> q=nex[n];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=q;j&lt;n;j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-Creating-the-Contest"><a href="#B-Creating-the-Contest" class="headerlink" title="B. Creating the Contest"></a>B. Creating the Contest</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>给定$n$个数，如果满足$a[i]*2≥a[i+1]$，则两数可以同时选择，求最大可选的连续串长度。</p><h4 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h4><p>对于每个数，判断其能否与下一个数同时选择，标记后遍历求最大值即可。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">bool</span> up[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=a[i]*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> pos=upper_bound(a,a+n,tmp)-a;</span><br><span class="line">        up[i]=(pos&gt;i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(up[i]==<span class="number">0</span>) cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            ans=max(ans,cnt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=max(ans,cnt);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-Maximal-Intersection"><a href="#C-Maximal-Intersection" class="headerlink" title="C. Maximal Intersection"></a>C. Maximal Intersection</h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>给定n个区间，求删除一个区间后可能达到的最大区间交集大小。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,a[<span class="number">3</span>]=&#123;<span class="number">-1</span>&#125;,b[<span class="number">3</span>]=&#123;<span class="number">-1</span>&#125;,x[<span class="number">2</span>],y[<span class="number">2</span>],l,r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>]==<span class="number">-1</span>||l&gt;a[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            a[<span class="number">1</span>]=a[<span class="number">0</span>];</span><br><span class="line">            a[<span class="number">0</span>]=l;</span><br><span class="line">            x[<span class="number">1</span>]=x[<span class="number">0</span>];</span><br><span class="line">            x[<span class="number">0</span>]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[<span class="number">1</span>]==<span class="number">-1</span>||l&gt;a[<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            a[<span class="number">1</span>]=l;</span><br><span class="line">            x[<span class="number">1</span>]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b[<span class="number">0</span>]==<span class="number">-1</span>||r&lt;b[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            b[<span class="number">1</span>]=b[<span class="number">0</span>];</span><br><span class="line">            b[<span class="number">0</span>]=r;</span><br><span class="line">            y[<span class="number">1</span>]=y[<span class="number">0</span>];</span><br><span class="line">            y[<span class="number">0</span>]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b[<span class="number">1</span>]==<span class="number">-1</span>||r&lt;b[<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            b[<span class="number">1</span>]=r;</span><br><span class="line">            y[<span class="number">1</span>]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x[<span class="number">0</span>]==y[<span class="number">0</span>]) ans=max(b[<span class="number">1</span>]-a[<span class="number">1</span>],<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans=max(b[<span class="number">0</span>]-a[<span class="number">1</span>],ans);</span><br><span class="line">        ans=max(b[<span class="number">1</span>]-a[<span class="number">0</span>],ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D-Concatenated-Multiples"><a href="#D-Concatenated-Multiples" class="headerlink" title="D. Concatenated Multiples"></a>D. Concatenated Multiples</h3><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>给定一个数组$a$，求其中的$a[i]$,$a[j]$拼接后能被$k$整除的$(i,j)$组数(其中$i≠j$)</p><h4 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h4><p>$x,y$拼接后能被$k$整除，等价于$(x·10^{n} \ mod\ k+y \mod k) \ mod \ k=0$ 其中$n$为$y$的位数。</p><p>对于每个数，枚举$a[i]·10^n(1≤n≤10)$，判断$len=n$且$a[i]·10^n +b[i]\ mod\ k+y \mod k) \ mod \ k=0$ 的数目即可。</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[maxn],b[maxn];</span><br><span class="line"><span class="keyword">int</span> len[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        n/=<span class="number">10</span>;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> s,tmp;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;s);</span><br><span class="line">        len[i]=cal(s);</span><br><span class="line">        a[i]=s%k;</span><br><span class="line">        b[i]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">10</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        mp.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) (b[i]*=<span class="number">10</span>)%=k,mp[b[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j==len[i])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp=k-a[i];</span><br><span class="line">                <span class="keyword">if</span>(tmp==k) tmp=<span class="number">0</span>;</span><br><span class="line">                ans+=mp[tmp];</span><br><span class="line">                <span class="keyword">if</span>(b[i]==tmp) ans--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Codeforces Round </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「POJ-3041」Asteroids (最小点覆盖)</title>
      <link href="/2018/08/23/POJ-3041/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://poj.org/problem?id=3041" target="_blank" rel="noopener">「POJ-3041」Asteroids</a><br>二分图匹配问题，行列覆盖模型+最小点覆盖</p></blockquote><a id="more"></a><hr><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个n×n的矩阵，矩阵中的某些点为小行星，每次可以消除一行或一列的小行星，问消除全部小行星所需的最小次数。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>对于矩阵中某个存在障碍的点，若要消除该点，则需要让该点被所在的行/列攻击覆盖。若全部障碍点都被行/列攻击覆盖，则全部障碍都被消除。</p><p>根据障碍点坐标建立二分图。对于原矩阵，将每行x看做一个X节点，将每列y看做一个Y节点。此时，边$x→y$代表一个障碍点。</p><p>问题转化为：如果选择了一个节点，就相当于覆盖了以它为端点的所有边，如何选择最少的节点，使二分图中所有边都被覆盖。即<strong>二分图的最小点覆盖</strong>。</p><p>对于此问题，我们有结论：</p><blockquote><p>König定理：二分图中的最大匹配数等于这个图中的最小点覆盖数。</p></blockquote><p>套用匈牙利算法求解最大匹配数即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">500</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> edge[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> linker[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">path</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">1</span>;v&lt;=n;v++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(edge[u][v]&amp;&amp;!vis[v])</span><br><span class="line">        &#123;</span><br><span class="line">            vis[v]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(linker[v]==<span class="number">-1</span>||path(linker[v]))</span><br><span class="line">            &#123;</span><br><span class="line">                linker[v]=u;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hungary</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(linker,<span class="number">0xff</span>,<span class="keyword">sizeof</span>(linker));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">            res+=path(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k,u,v;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(edge,<span class="number">0</span>,<span class="keyword">sizeof</span>(edge));</span><br><span class="line">        <span class="keyword">while</span>(k--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">            edge[u][v]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,hungary());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分图匹配 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018 Multi-University Nowcoder Round 8 - H Playing games（FWT,博弈）</title>
      <link href="/2018/08/15/Nowcoder-Summer-Round8-H/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="https://www.nowcoder.com/acm/contest/146/H" target="_blank" rel="noopener">H-Playing games</a><br>Nim博弈模型，在所给的n堆中选择使后手必胜的最大堆数</p></blockquote><a id="more"></a><hr><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>在$n$堆石子中选择最大数量的堆数，使得对于取出的$n$堆石子，在进行Nim游戏时后手必胜。</p><p><del>这样例膜得也太暴力了吧，苟利苟利苟利.jpg</del></p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>对于Nim游戏的局面，当且仅当$a_1⊕ a_2⊕ a_3…⊕ a_n=0$时，它是P-position（后手必胜），其中⊕ 表示异或(XOR)运算。</p><p>此题可以转化为，在$n$个数中寻找最多的数，使SUM_XOR=0.</p><p>我们再将题意转化为，在$n$个数中寻找最少的数，使SUM_XOR=C，其中，$C=a_1⊕ a_2⊕ ……⊕ a_n$</p><p>此处引入Fast Walsh-Hadamard Transform(FWT,快速沃尔什变换)求解。</p><h4 id="Fast-Walsh-Hadamard-Transform"><a href="#Fast-Walsh-Hadamard-Transform" class="headerlink" title="Fast Walsh-Hadamard Transform"></a>Fast Walsh-Hadamard Transform</h4><h5 id="FWT的详解参考："><a href="#FWT的详解参考：" class="headerlink" title="FWT的详解参考："></a>FWT的详解参考：</h5><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%B2%83%E7%88%BE%E4%BB%80%E8%BD%89%E6%8F%9B" target="_blank" rel="noopener">快速沃尔什转换 - 维基百科</a><br><a href="http://picks.logdown.com/posts/179290-fast-walsh-hadamard-transform" target="_blank" rel="noopener">Fast Walsh-Hadamard Transform</a><br><a href="https://www.cnblogs.com/cjyyb/p/9065615.html" target="_blank" rel="noopener">FWT快速沃尔什变换学习笔记</a></p></blockquote><p>FWT是用于解决<strong>多项式位运算卷积</strong>的一类方法，如下：</p><p>$$C_k=\sum_{i⊕j=k}A_i*B_j$$</p><p>对于数组A，我们设其在经过快速沃尔什变换后记作$FWT[A]$</p><p>我们需要一个新序列C，由序列A和序列B经过某运算规则得到，即$C=A⊕B$</p><p>我们先正向得到$FWT[A],FWT[B]$，然后根据$FWT[C]=FWT[A]*FWT[B]$求出$FWT[C]$，然后逆向运算得到原序列C，复杂度为$O(nlog(n))$</p><p>对于异或（XOR）卷积有：</p><p>$$tf(A)=(tf(A_0)+tf(A_1)),tf(A_0)-tf(A_1)) $$<br>$$utf(A)=(utf(\frac{A_0+A_1}{2}),utf(\frac{A_0-A_1}{2}))$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FWT_xor</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> opt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p=i&lt;&lt;<span class="number">1</span>,j=<span class="number">0</span>;j&lt;N;j+=p)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;++k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> X=a[j+k],Y=a[i+j+k];</span><br><span class="line">                a[j+k]=(X+Y)%MOD;a[i+j+k]=(X+MOD-Y)%MOD;</span><br><span class="line">                <span class="keyword">if</span>(opt==<span class="number">-1</span>)a[j+k]=<span class="number">1l</span>l*a[j+k]*inv2%MOD,a[i+j+k]=<span class="number">1l</span>l*a[i+j+k]*inv2%MOD;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>对于本题，我们考虑将$a_i$的每一维拆开，看作一个$d$维向量，由于$a_i&lt;2^{19}$，取$d=19$</p><p>二分答案，取其在异或卷积意义下的$k$次幂，判断能否合成C即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1</span>&lt;&lt;<span class="number">19</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="keyword">int</span> l,r,mid;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FWT</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p=i&lt;&lt;<span class="number">1</span>,j=<span class="number">0</span>;j&lt;n;j+=p)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x=a[j+k],y=a[i+j+k];</span><br><span class="line">                a[j+k]=(x+y)%mod;a[i+j+k]=(x+mod-y)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,x,aim=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        aim^=x;</span><br><span class="line">        a[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!aim) <span class="keyword">return</span> <span class="number">0</span>*<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n);</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">19</span>,mid;</span><br><span class="line">    a[<span class="number">0</span>]++;</span><br><span class="line">    FWT(a,<span class="number">1</span>&lt;&lt;<span class="number">19</span>);</span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;<span class="number">19</span>);i++)</span><br><span class="line">        &#123;</span><br><span class="line">            b[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;mid;j++)</span><br><span class="line">                b[i]=<span class="number">1l</span>l*b[i]*a[i]%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        FWT(b,<span class="number">1</span>&lt;&lt;<span class="number">19</span>);</span><br><span class="line">        <span class="keyword">if</span>(b[aim]) r=mid; </span><br><span class="line">        <span class="keyword">else</span> l=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n-r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博弈 </tag>
            
            <tag> FWT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「CodeForces-191C」Fools and Roads(LCA+树上差分/树链剖分)</title>
      <link href="/2018/08/13/Codeforces-191C/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://codeforces.com/problemset/problem/191/C" target="_blank" rel="noopener">「CodeForces-191C」Fools and Roads</a><br>LCA+树上差分/树链剖分，求树边的染色次数</p></blockquote><a id="more"></a><hr><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个$N$节点的树，以及树上的$k$条简单路径（端点用$u$,$v$表示），求树上的各条边被$k$条简单路径经过的总次数。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="LCA-树上差分"><a href="#LCA-树上差分" class="headerlink" title="LCA+树上差分"></a>LCA+树上差分</h3><p>对于树上的简单路径$path(u,v)$，如果对于每一次查询，都对路径$path(u_i,v_i)$上经过的每一条边的权值+1，时间复杂度为$O(k*n)=1e10$，显然我们需要优化时间复杂度。</p><p>我们引入<strong>树上差分</strong>（树的前缀和）来优化查询。</p><h4 id="树上差分"><a href="#树上差分" class="headerlink" title="树上差分"></a>树上差分</h4><p>对于树，有如下两个性质：</p><ol><li>任意两个节点之间有且只有一条路径；</li><li>根节点确定时，一个节点只有一个父亲节点。</li></ol><p>由此，在自根节点向下进行DFS时，对于$path(u,v)$的其中任意一点$u’≠r$，若$u’$被访问，则$u’$的父亲节点一定被访问。</p><p>基于这样的性质，我们将树上的路径$path(u,v)$分割为两条链，有$r=LCA(u,v)$，路径$path(u,v)$覆盖的边为$u→r$，$r→v$，对两条链分别进行差分。</p><p>关于边的差分中，$r=LCA(u,v)​$不包含在内。因此考虑链$u→r​$，有<code>cf[u]++</code>,<code>cf[r]​--</code>；同样的，对于链$r→v​$，有<code>cf[v]​++</code>,<code>cf[r]​--</code>，即</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">for</span> <span class="title">each</span><span class="params">(u,v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r=LCA(u,v);</span><br><span class="line">    cf[r]-=<span class="number">2</span>;</span><br><span class="line">    cf[u]++;</span><br><span class="line">    cf[v]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在完成所有$path$的查询后，自根节点进行$DFS$求树上每个点的前缀和，此时，对于树边$path(u,v)$，$cf[v]$即为此条边经过的总次数，即，对于树上的每条边$path(u,v)$，有</p><p>$$ans[path(u,v)]=cf[v]$$</p><p>时间复杂度为$O(n)$</p><p>如，对于样例1</p><p><img src="/2018/08/13/Codeforces-191C/pic1.png" alt="pic1"></p><p>对每一组查询$path$求LCA后有</p><p><img src="/2018/08/13/Codeforces-191C/pic3.png" alt="pic3"></p><p>DFS求前缀和，即为所求解</p><p><img src="/2018/08/13/Codeforces-191C/pic2.png" alt="pic2"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[maxn],pre[maxn],ans[maxn],cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; query[maxn];</span><br><span class="line"><span class="keyword">int</span> cf[maxn]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nex,to,no;</span><br><span class="line">&#125;edge[<span class="number">2</span>*maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> no)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].nex=head[u];</span><br><span class="line">    edge[cnt].to=v;</span><br><span class="line">    edge[cnt].no=no;</span><br><span class="line">    head[u]=cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==pre[x]?x:pre[x]=Find(pre[x]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=Find(x),b=Find(y);</span><br><span class="line">    <span class="keyword">if</span>(a!=b) pre[b]=a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];~i;i=edge[i].nex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        Tarjan(v,u);</span><br><span class="line">        Union(u,v);</span><br><span class="line">        vis[v]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;query[u].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> e=query[u][i];</span><br><span class="line">        <span class="keyword">if</span>(vis[e])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> root=Find(e);</span><br><span class="line">            cf[root]-=<span class="number">2</span>;</span><br><span class="line">            cf[e]+=<span class="number">1</span>;</span><br><span class="line">            cf[u]+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];~i;i=edge[i].nex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        cf[u]+=dfs(v,u);</span><br><span class="line">        ans[edge[i].no]+=cf[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cf[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,u,v,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0xff</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        pre[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">        add(u,v,i);</span><br><span class="line">        add(v,u,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">    <span class="keyword">while</span>(k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">        query[u].push_back(v);</span><br><span class="line">        query[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    Tarjan(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h3><p>（待补）</p>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCA </tag>
            
            <tag> 树上差分 </tag>
            
            <tag> 树链剖分 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「POJ-3494」Largest Submatrix of All 1’s(单调栈)</title>
      <link href="/2018/08/09/POJ-3494/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://poj.org/problem?id=3494" target="_blank" rel="noopener">「POJ-3494」Largest Submatrix of All 1’s </a><br>单调栈，寻找01矩阵中最大的元素全为1的子矩阵</p></blockquote><a id="more"></a><hr><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个$m×n$的$01$矩阵，求只包含元素$1$的最大子矩阵。</p><p>对于每一组输入，输出最大全$1$子矩阵的元素数目。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题的暴力解法，即对于图中的每一个点$(i,j)$,枚举其右下方的每一个点，检测自$(i,j)$到$(x,y)$组成的子矩阵元素是否全为1.复杂度为$O(n^3m^3)$.</p><p>显然我们需要优化复杂度。</p><p>对于如下矩阵：</p><p>$$<br>\begin{vmatrix}<br>    0 &amp; 1 &amp; 0 &amp; 1 &amp; 0\<br>    0 &amp; 1 &amp;1 &amp; 0 &amp; 0\<br>    1 &amp; 1 &amp; 1 &amp; 0 &amp; 0\<br>    0 &amp; 0 &amp; 0 &amp; 0 &amp;1\<br>\end{vmatrix}<br>$$<br>枚举每行元素</p><p><img src="/2018/08/09/POJ-3494/1533815577042.png" alt="1533815577042"></p><p><img src="/2018/08/09/POJ-3494/1533815742193.png" alt="1533815742193"></p><p><img src="/2018/08/09/POJ-3494/1533815953866.png" alt="1533815953866"></p><p><img src="/2018/08/09/POJ-3494/1533816076001.png" alt="1533816076001"></p><p>即对于矩阵的每一行，枚举以每一行为底，柱状图所能形成的最大矩形面积，所有行中的最大值即为答案。</p><p>问题转化为</p><blockquote><p><a href="http://poj.org/problem?id=2559" target="_blank" rel="noopener">POJ2559 Largest Rectangle in a Histogram </a></p><p><img src="http://poj.org/images/2559_1.jpg" alt="img"> </p></blockquote><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>基于原矩阵，构造一个新矩阵<br>$$<br>\begin{matrix}<br>    0 &amp; 1 &amp; 0 &amp; 1 &amp; 0\<br>    0 &amp; 2  &amp; 1  &amp; 0 &amp; 0\<br>    1 &amp; 3 &amp; 2 &amp; 0 &amp; 0\<br>    0 &amp; 0 &amp; 0 &amp; 0 &amp;1\<br>\end{matrix}<br>$$<br>对于每一行，套用POJ2559的方法，使用单调栈求解当前行的最大值，再遍历求出总的最大值即可。</p><h4 id="POJ2559-最大矩形面积"><a href="#POJ2559-最大矩形面积" class="headerlink" title="POJ2559 最大矩形面积"></a>POJ2559 最大矩形面积</h4><p>对于最大矩形面积，我们需要找到每一个柱状块向左、右所能扩展的区间的最大长度。即，区间内的柱状块高度都不小于起始柱状块的高度。</p><p>使用单调栈维护一个从起点到当前点的单调递增序列，如果栈顶元素的高度大于当前点，弹出栈顶元素，直到栈为空，或栈顶元素小于当前点，以此来维护栈的递增性。</p><p>我们需要证明，之前弹出的元素对之后的点没有影响，即$i$之前大于$h[i]$的元素，必然不是$h[i+1]$的扩展边界：</p><ul><li><p>若$h[i]&lt;h[i+1]$，点$i+1$ 显然无法向左继续扩展，边界为$h[i]$</p></li><li><p>若$h[i]≥h[i+1]$，之前出栈的点一定大于$h[i]$，不影响$i+1$向左继续扩展</p></li></ul><p>以上结论具有递推性，可用数学归纳法证明。</p><p>由此我们可以线性求出每个元素向左、右扩展形成的最大矩形面积，即<code>s[i]=(l[i]+r[i]+1)*h[i]</code></p><blockquote><p><a href="https://github.com/V-Verly/ACM/blob/master/POJ/2559/15293982_AC_266ms_2812kB.cpp" target="_blank" rel="noopener">Code|Solution to POJ 2559</a></p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn],l[maxn],r[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">                <span class="keyword">if</span>(x) a[i][j]=a[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> a[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!st.empty()&amp;&amp;a[i][st.top()]&gt;=a[i][j]) st.pop();</span><br><span class="line">                <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st.empty()) res=st.top();</span><br><span class="line">                st.push(j);</span><br><span class="line">                l[j]=(j<span class="number">-1</span>-res)*a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!st.empty()) st.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=n;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!st.empty()&amp;&amp;a[i][st.top()]&gt;=a[i][j]) st.pop();</span><br><span class="line">                <span class="keyword">int</span> res=n;</span><br><span class="line">                <span class="keyword">if</span>(!st.empty()) res=st.top()<span class="number">-1</span>;</span><br><span class="line">                st.push(j);</span><br><span class="line">                r[j]=(res-j)*a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">                ans=max(ans,l[j]+r[j]+a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「HDU-2196」Computer (树形DP)</title>
      <link href="/2018/07/21/HDU-2196/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2196" target="_blank" rel="noopener">「HDU-2196」Computer</a><br>树形dp，树的最长路径（最远点对）</p></blockquote><a id="more"></a><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一棵$n$个结点的无根树，求出每个结点所能到达的最远点的距离。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>将无根树转成有根树，并进行两次DFS。</p><ol><li><p>第一次DFS求出每个结点在其子树中的<strong>正向最大距离</strong>和<strong>正向次大距离</strong>,记为<code>longest[i]</code>和<code>secondary[i]</code>，并标记最长距离所对应的子结点<code>mark[i]</code>；</p><p>此时可知对于每个结点$i$,最远点的距离只有两种可能：</p><ul><li>结点$i$的<strong>正向最大距离</strong></li><li>结点$i$链接其父结点所能到达的最大距离，即<strong>反向最大距离</strong></li></ul></li><li><p>第二次DFS求出反向最长距离<code>top[i]</code></p><ul><li><p>若其父节点的正向最大距离不经过$i$，反向最大距离为父节点的正向最大距离/反向最大距离+连接边</p><p>$$top[i]=max(top[fa],longest[fa])+edge[fa][i]$$</p></li><li><p>否则，反向最大距离为父节点的正向次大距离/反向最大距离+连接边</p><p>$$top[i]=max(top[fa],secondary[fa])+edge[fa][i]$$</p></li></ul></li></ol><p>最终所求每个点的最大距离$ans[i]=max(longest[i],top[i])$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[maxn],tot,longest[maxn],secondary[maxn],top[maxn],mark[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,nex,v;</span><br><span class="line">node()&#123;&#125;</span><br><span class="line">node(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c):to(a),nex(b),v(c)&#123;&#125;</span><br><span class="line">&#125;edge[<span class="number">2</span>*maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">edge[tot]=node(v,head[u],w);</span><br><span class="line">head[u]=tot++;</span><br><span class="line">edge[tot]=node(u,head[v],w);</span><br><span class="line">head[v]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">longest[u]=secondary[u]=<span class="number">0</span>;</span><br><span class="line">mark[u]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=head[u];k!=<span class="number">-1</span>;k=edge[k].nex)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=edge[k].to;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">dfs(v,u);</span><br><span class="line"><span class="keyword">if</span>(longest[u]&lt;=longest[v]+edge[k].v)</span><br><span class="line">&#123;</span><br><span class="line">secondary[u]=longest[u];</span><br><span class="line">longest[u]=longest[v]+edge[k].v;</span><br><span class="line">mark[u]=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(secondary[u]&lt;=longest[v]+edge[k].v&amp;&amp;mark[u]!=v)</span><br><span class="line">secondary[u]=longest[v]+edge[k].v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=head[u];k!=<span class="number">-1</span>;k=edge[k].nex)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=edge[k].to;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(mark[u]!=v)</span><br><span class="line">top[v]=max(longest[u],top[u])+edge[k].v;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">top[v]=max(secondary[u],top[u])+edge[k].v;</span><br><span class="line">dfs1(v,u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N)!=EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v,w;</span><br><span class="line">tot=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">2</span>;u&lt;=N;u++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;v,&amp;w);</span><br><span class="line">add(u,v,w);</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">memset</span>(top,<span class="number">0</span>,<span class="keyword">sizeof</span>(top));</span><br><span class="line">dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">top[<span class="number">1</span>]=secondary[<span class="number">1</span>]; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,max(top[i],longest[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 树形DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「HDU-4616」Game (树形DP)</title>
      <link href="/2018/07/19/HDU-4616/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4616" target="_blank" rel="noopener">「HDU-4616」Game</a><br>树形DP，有限制的权值最大链问题</p></blockquote><a id="more"></a><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给一棵有$n$个节点的树，每个节点有其$val$值和$trap$值（1表示该点有陷阱，0为无陷阱），最多可掉进陷阱$c$次。经过树上某一点时将取得该点的$val$值，踩到第$c$个陷阱后马上停止，且不能走已经走过的点。求最大能获得的$val$值之和。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>树形dp。</p><p>每个节点的状态可用<code>dp[u][k][flag]</code>表示，<code>flag=1</code>时，表示在以$u$为根的子树上，从一个<strong>有陷阱的起点</strong>经过$k$个陷阱走到$u$的最大值；若<code>flag=0</code>，则表示起点没有陷阱。</p><p>考虑最优解共走过$k$个陷阱，如果<code>k!=c</code>,那么起点和终点都可以为没有陷阱的点，如果<code>k=c</code>,那么起点和终点至少有一点为有陷阱点。</p><h4 id="状态转移方程："><a href="#状态转移方程：" class="headerlink" title="状态转移方程："></a>状态转移方程：</h4><ol><li><p>当$u$点的起点<strong>有陷阱</strong>时，在$0&lt;k≤c$上，对$u$的子节点$v$有：</p><p>$$dp[u][k+1][1]=max(dp[u][k+1][1],dp[v][k+1][1]+val[u])$$</p></li><li><p>当$u$点起点<strong>没有陷阱</strong>时，在$0≤k≤c$上，对$u$的子节点$v$有：</p><p>$$dp[u][k][0]=max(dp[u][k][0],dp[v][k][0]+val[u])$$</p><p>对于情况1，由于不存在总陷阱数为0且起点为陷阱的情况，故<code>k！=0</code>.</p></li></ol><h5 id="以上两式可合写为："><a href="#以上两式可合写为：" class="headerlink" title="以上两式可合写为："></a>以上两式可合写为：</h5><p>$$dp[u][k+trap[u]][flag]=max(dp[u][k+trap[u]][flag],dp[v][k][flag]+val[u])$$</p><h4 id="对于最优解-ans"><a href="#对于最优解-ans" class="headerlink" title="对于最优解$ans$:"></a>对于最优解$ans$:</h4><p>最优解可以看成两条链拼在一起，枚举两条链的陷阱个数并求和更新最优解。</p><h5 id="更新最优解时需要注意："><a href="#更新最优解时需要注意：" class="headerlink" title="更新最优解时需要注意："></a>更新最优解时需要注意：</h5><ol><li>当两条链的陷阱总数<code>j+k=c</code>时，两条链的起点不可能同时为0；</li><li>不存在总陷阱数为0且起点陷阱值为1的情况；</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,c;</span><br><span class="line"><span class="keyword">int</span> val[maxn],trap[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][<span class="number">5</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dp[u][trap[u]][trap[u]]=val[u];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tree[u].size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=tree[u][i];</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">dfs(v,u);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=c;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;j+k&lt;=c;k++)</span><br><span class="line">&#123;</span><br><span class="line">ans=max(ans,dp[u][j][<span class="number">1</span>]+dp[v][k][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span>(j+k&lt;c) ans=max(ans,dp[u][j][<span class="number">0</span>]+dp[v][k][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span>(k) ans=max(ans,dp[u][j][<span class="number">0</span>]+dp[v][k][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span>(j) ans=max(ans,dp[u][j][<span class="number">1</span>]+dp[v][k][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k+trap[u]&lt;=c;k++)</span><br><span class="line">&#123;</span><br><span class="line">dp[u][k+trap[u]][<span class="number">0</span>]=max(dp[u][k+trap[u]][<span class="number">0</span>],dp[v][k][<span class="number">0</span>]+val[u]);</span><br><span class="line"><span class="keyword">if</span>(k) dp[u][k+trap[u]][<span class="number">1</span>]=max(dp[u][k+trap[u]][<span class="number">1</span>],dp[v][k][<span class="number">1</span>]+val[u]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t,u,v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;c);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">tree[i].clear();</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;val[i],&amp;trap[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">tree[u].push_back(v);</span><br><span class="line">tree[v].push_back(u);</span><br><span class="line">&#125;</span><br><span class="line">ans=<span class="number">0</span>;</span><br><span class="line">dfs(<span class="number">0</span>,<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 树形DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「HDU-1520」Anniversary party (树形DP)</title>
      <link href="/2018/07/19/HDU-1520/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1520" target="_blank" rel="noopener">「HDU-1520」Anniversary party</a><br>树形DP，树的最大独立集问题</p></blockquote><a id="more"></a><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给一颗n个结点的无根树，选出一系列结点，使得在任何两个结点均不相邻的情况下，结点的权值和最大。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>树的最大独立集问题。</p><p>用$d(i)$表示以$i$为根节点的子树的最大独立集大小。对于结点$i$只有两种决策：选和不选。如果不选$i$,则问题转化成了求出$i$的所有儿子的$d$值再相加；如果选$i$,则它的儿子全部不能选，问题转化为了求出$i$的所有孙子的$d$之和。</p><p>状态转移方程为：</p><p>$$d(i)=max{\sum_{j∈s(i)}d(j),\sum_{j∈gs(i)}d(j)+val(i)}$$</p><p>其中$gs(i)$与$s(i)$分别为$i$的孙子集合与儿子集合。</p><p>实现方法：当计算出一个$d(i)$后，用它去更新$i$的父节点和祖父节点。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">6000</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree[maxn];</span><br><span class="line"><span class="keyword">int</span> d[maxn],s[maxn],gs[maxn];</span><br><span class="line"><span class="keyword">int</span> N,val[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tree[u].size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=tree[u][i];</span><br><span class="line"><span class="keyword">if</span>(v!=fa) dfs(v,u);</span><br><span class="line">s[u]+=d[v];</span><br><span class="line"><span class="keyword">if</span>(fa) gs[fa]+=d[v];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[u]=max(s[u],gs[u]+val[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N)!=EOF)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;val[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line">d[i]=s[i]=gs[i]=<span class="number">0</span>;</span><br><span class="line">tree[i].clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v)==<span class="number">2</span>&amp;&amp;(u||v))</span><br><span class="line">&#123;</span><br><span class="line">tree[u].push_back(v);</span><br><span class="line">tree[v].push_back(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dfs(<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 树形DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「HDU-1827」Summer Holiday (强联通分量)</title>
      <link href="/2018/07/18/HDU-1827/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1827" target="_blank" rel="noopener">「HDU-1827」Summer Holiday</a><br>Tarjan强联通分量+缩点，求最小联系费用</p></blockquote><a id="more"></a><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>强联通分量+缩点，判断每个强连通分量的入度是否为0，如果为0，则说明没有人能联系到这个分量中的任意一点。在同一强联通分量内，任意两点互相通达，所以只要其入度不为0，就代表整个强联通分量内的点都能被图中其它点通知信息。故Wiskey只要通知所有入度为0的强联通分量中的任意一点，就能通知到所有人。对于每一个入度为0的强联通分量，所需的联系费用即为其中花费最小的节点的费用（即点权最小的点的权值）。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; edge[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[maxn],low[maxn],cost[maxn],belong[maxn],degree[maxn];</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[maxn],index,tot,scc;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[v]=low[v]=++tot;</span><br><span class="line">    <span class="built_in">stack</span>[++index]=v;</span><br><span class="line">    vis[v]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edge[v].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=edge[v][i];</span><br><span class="line">        <span class="keyword">if</span>(!dfn[u])</span><br><span class="line">        &#123;</span><br><span class="line">            Tarjan(u);</span><br><span class="line">            low[v]=min(low[v],low[u]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vis[u])</span><br><span class="line">            low[v]=min(low[v],dfn[u]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[v]==dfn[v])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u;</span><br><span class="line">        belong[v]=++scc;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            u=<span class="built_in">stack</span>[index];</span><br><span class="line">            vis[u]=<span class="literal">false</span>;</span><br><span class="line">            belong[u]=scc;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;<span class="keyword">while</span>(u!=v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,u,v;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;cost[i]);</span><br><span class="line">            edge[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">            edge[u].push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dfn,<span class="number">0</span>,<span class="keyword">sizeof</span>(dfn));</span><br><span class="line">        <span class="built_in">memset</span>(degree,<span class="number">0</span>,<span class="keyword">sizeof</span>(degree));</span><br><span class="line">        tot=index=scc=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">if</span>(!dfn[i]) Tarjan(i);<span class="comment">//Tarjan求强联通分量+缩点</span></span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">1</span>;v&lt;=n;v++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;edge[v].size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> u=edge[v][j];</span><br><span class="line">                <span class="keyword">if</span>(belong[v]!=belong[u])<span class="comment">//不在同一个强连通分量内</span></span><br><span class="line">                    degree[belong[u]]++;<span class="comment">//入度+1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=scc;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!degree[i])<span class="comment">//该强联通分量的入度为0</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="keyword">int</span> mincost=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(belong[j]==i)<span class="comment">//该点在强连通分量内</span></span><br><span class="line">                        mincost=min(mincost,cost[j]);<span class="comment">//求该强联通分量内点权最小的点的权值</span></span><br><span class="line">                &#125;</span><br><span class="line">                sum+=mincost;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,ans,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Graph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 强连通分量 </tag>
            
            <tag> Tarjan </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「POJ-1655」Balancing Act（树形DP）</title>
      <link href="/2018/05/29/POJ-1655-Balancing-Act/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://poj.org/problem?id=1655" target="_blank" rel="noopener">「POJ-1655」Balancing Act</a><br>树形DP，树的重心（质心）</p></blockquote><a id="more"></a><hr><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p><strong>树的重心（质心）</strong>。对于一棵n个节点的无根树，找到一个点，使得把树变成以该点为根的有根树时，最大子树的节点最小。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>先任选一个节点作为根，把无根树变成有根树，然后设d(i)表示以i为根的子树的节点个数。不难发现$d(i)=\sum_{j∈s(i)}d(j)+1$ 。删除节点i后，节点i的子树中最大有max{d(j)}个节点，i的“上方子树”中有n-d(i)个节点。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> d[maxn],N,minNode,minBalance;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node,<span class="keyword">int</span> father)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d[node]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxSubTree=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tree[node].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> son=tree[node][i];</span><br><span class="line">        <span class="keyword">if</span>(son!=father)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(son,node);</span><br><span class="line">            d[node]+=d[son];</span><br><span class="line">            maxSubTree=max(maxSubTree,d[son]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    maxSubTree=max(maxSubTree,N-d[node]);</span><br><span class="line">    <span class="keyword">if</span>(maxSubTree&lt;minBalance)</span><br><span class="line">    &#123;</span><br><span class="line">        minBalance=maxSubTree;</span><br><span class="line">        minNode=node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,u,v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++)</span><br><span class="line">            tree[i].clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">            tree[u].push_back(v);</span><br><span class="line">            tree[v].push_back(u);</span><br><span class="line">        &#125;</span><br><span class="line">        minNode=<span class="number">0</span>;</span><br><span class="line">        minBalance=inf;</span><br><span class="line">        dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,minNode,minBalance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 树形DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Codeforces Round 483 (Div. 2)</title>
      <link href="/2018/05/17/Codeforces%20Round%20483%20(Div.%202)%20/"/>
      <content type="html"><![CDATA[<blockquote><p><a href="http://codeforces.com/contest/984" target="_blank" rel="noopener">Codeforces Round #483 (Div. 2) </a></p></blockquote><p><del>已经是条只会签到全靠补题的咸鱼了</del></p><a id="more"></a><hr><h3 id="A-Game"><a href="#A-Game" class="headerlink" title="A.Game"></a>A.Game</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>两方轮流删最大、最小的数，求最后剩下的值。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,a[<span class="number">1005</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    sort(a,a+n);</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[n/<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[n/<span class="number">2</span><span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="B-Minesweeper"><a href="#B-Minesweeper" class="headerlink" title="B. Minesweeper"></a>B. Minesweeper</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>给一张扫雷地图，判断标记数字有没有出现错误。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">8</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">8</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> fx=x+dx[i],fy=y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(fx&gt;=<span class="number">0</span>&amp;&amp;fx&lt;n&amp;&amp;fy&gt;=<span class="number">0</span>&amp;&amp;fy&lt;m&amp;&amp;a[fx][fy]==<span class="string">'*'</span>) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a[i]);</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j]==<span class="string">'*'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j]==<span class="string">'.'</span>) tmp=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> tmp=a[i][j]-<span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(tmp!=sum(i,j)) flag=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,flag?<span class="string">"YES"</span>:<span class="string">"NO"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="C-Finite-or-not"><a href="#C-Finite-or-not" class="headerlink" title="C. Finite or not?"></a>C. Finite or not?</h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>给出三个整数p,q,b,判断p/q在b进制下是否是一个有限小数。</p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>数论题。</p><p>首先在10进制下，一个分数在化为最简分数的情况下，如果它的分母只含有2和5两个质因数，这个分数就能化简为有限小数。</p><p>推广得在b进制下，如果化简后的p/q中的分母只含有b的质因数，那么该分数是一个有限小数。即q在与b的公因数的不断整除下，q能否被化简为1.</p><p>需要注意这里如果每步直接取<code>tmp=gcd(q,b)</code>则会导致tle，由$$gcd(\frac{p}{gcd(b,p)},b)=gcd(\frac{p}{gcd(b,p)},gcd(b,p))$$,则只需要取<code>tmp=gcd(q,tmp)</code>并不断整除q,tmp的公因数直到q=1（p/q为有限小数）或tmp=1（p≠1且不能继续化简，p/q为无限小数）即可</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b==<span class="number">0</span>?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> p,q,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;p,&amp;q,&amp;b);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tmp=gcd(p,q);</span><br><span class="line">        q/=tmp;</span><br><span class="line">        tmp=gcd(q,b);</span><br><span class="line">        <span class="keyword">while</span>(q&gt;<span class="number">1</span>&amp;&amp;tmp&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp=gcd(q,tmp);</span><br><span class="line">            q/=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,q==<span class="number">1</span>?<span class="string">"Finite"</span>:<span class="string">"Infinite"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="D-XOR-pyramid"><a href="#D-XOR-pyramid" class="headerlink" title="D. XOR-pyramid"></a>D. XOR-pyramid</h3><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>对于长度为m的数组b，定义函数$$f$$如下</p><p>$$f(b) = \begin{cases} b[1] &amp; \quad \text{if } m = 1 \ f(b[1] \oplus b[2],b[2] \oplus b[3],\dots,b[m-1] \oplus b[m]) &amp; \quad \text{otherwise,} \end{cases}$$</p><p>其中⊕为异或运算，例：</p><p>$f(1,2,4,8)=f(1\oplus2,2\oplus4,4\oplus8)=f(3,6,12)=f(3\oplus6,6\oplus12)=f(5,10)=f(5\oplus10)=f(15)=15$</p><p>给定一个数组和一系列询问，求区间$$[l,r]$$内$$f$$的最大值。</p><h4 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h4><p>打表记录左右区间为$$[l,r]$$的$$f$$值dp[l][r]，i=l=r的值即为a[i]本身，通过<code>dp[l][r]=dp[l][r-1]^dp[l+1][r]</code>依次求出区间长度为1～n的f值（区间长度为k=r-l），再通过<code>dp[l][r]=max(dp[l+1][r],dp[l][r],dp[l][r-1])</code>逐步更新最大值。</p><p>其实就是个数塔形式的dp，计算过程中取左下方和右下方的值求异或和并记录，dp更新过程中取三者的最大值更新就可以了，如下</p><p>$f(1,2,4,8)=f(1\oplus2,2\oplus4,4\oplus8)=f(3,6,12)=f(3\oplus6,6\oplus12)=f(5,10)=f(5\oplus10)=f(15)=15$</p><p>$$15$$</p><p>$$5\qquad10$$</p><p>$$3\qquad6\qquad12$$</p><p>$$1\qquad2\qquad4\qquad8$$</p><p>与下方左右两数比较并更新后</p><p>$$15$$</p><p>$$[6]\qquad[12]$$</p><p>$$3\qquad6\qquad12$$</p><p>$$1\qquad2\qquad4\qquad8$$</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">5000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,l,r,t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;dp[i][i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;n;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+k&lt;=n;i++)</span><br><span class="line">            dp[i][i+k]=dp[i][i+k<span class="number">-1</span>]^dp[i+<span class="number">1</span>][i+k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+k&lt;=n;i++)</span><br><span class="line">        dp[i][i+k]=max(max(dp[i+<span class="number">1</span>][i+k],dp[i][i+k]),dp[i][i+k<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[l][r]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="E-Elevator"><a href="#E-Elevator" class="headerlink" title="E. Elevator"></a>E. Elevator</h3><p><del><em>那我哪会</em></del></p>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Codeforces Round </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> Codeforces </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
